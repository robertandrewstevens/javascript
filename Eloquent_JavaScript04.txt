“On two occasions I have been asked, ‘Pray, Mr. Babbage, if you put into the machine wrong figures, will the right answers come out?’ [...] I am not able rightly to apprehend the kind of confusion of ideas that could provoke such a question.”—Charles Babbage, Passages from the Life of a Philosopher (1864)4 Data Structures: Objects and ArraysNumbers, Booleans, and strings are the bricks that data structures are built from. But you can’t make much of a house out of a single brick. Objects allow us to group values—including other objects—together and thus build more complex structures.The programs we have built so far have been seriously hampered by the fact that they were operating only on simple data types. This chapter will add a basic understanding of data structures to your toolkit. By the end of it, you’ll know enough to start writing some useful programs.The chapter will work through a more or less realistic programming example, introducing concepts as they apply to the problem at hand. The example code will often build on functions and variables that were introduced earlier in the text.The online coding sandbox for the book (eloquentjavascript.net/code) provides a way to run code in the context of a specific chapter. If you decide to work through the examples in another environment, be sure to first download the full code for this chapter from the sandbox page.The weresquirrelEvery now and then, usually between eight and ten in the evening, Jacques finds himself transforming into a small furry rodent with a bushy tail.On one hand, Jacques is quite glad that he doesn’t have classic ly- canthropy. Turning into a squirrel tends to cause fewer problems than turning into a wolf. Instead of having to worry about accidentally eating the neighbor (that would be awkward), he worries about being eaten by the neighbor’s cat. After two occasions where he woke up on a precari-61
ously thin branch in the crown of an oak, naked and disoriented, he has taken to locking the doors and windows of his room at night and putting a few walnuts on the floor to keep himself busy.That takes care of the cat and oak problems. But Jacques still suffers from his condition. The irregular occurrences of the transformation make him suspect that they might be triggered by something. For a while, he believed that it happened only on days when he had touched trees. So he stopped touching trees entirely and even avoided going near them. But the problem persisted.Switching to a more scientific approach, Jacques intends to start keep- ing a daily log of everything he did that day and whether he changed form. With this data he hopes to narrow down the conditions that trig- ger the transformations.The first thing he does is design a data structure to store this infor- mation.Data setsTo work with a chunk of digital data, we’ll first have to find a way to represent it in our machine’s memory. Say, as a simple example, that we want to represent a collection of numbers: 2, 3, 5, 7, and 11.We could get creative with strings—after all, strings can be any length, sowecanputalotofdataintothem—anduse"2 3 5 7 11" asourrep- resentation. But this is awkward. You’d have to somehow extract the digits and convert them back to numbers to access them.62
Fortunately, JavaScript provides a data type specifically for storing sequences of values. It is called an array and is written as a list of values between square brackets, separated by commas.var listOfNumbers = [2, 3, 5, 7, 11]; console.log(listOfNumbers[1]);// → 3console.log(listOfNumbers[1 - 1]);// → 2The notation for getting at the elements inside an array also uses square brackets. A pair of square brackets immediately after an expression, with another expression inside of them, will look up the element in the left- hand expression that corresponds to the index given by the expression in the brackets.The first index of an array is zero, not one. So the first element can be read with listOfNumbers[0]. If you don’t have a programming background, this convention might take some getting used to. But zero-based count- ing has a long tradition in technology, and as long as this convention is followed consistently (which it is, in JavaScript), it works well.PropertiesWe’ve seen a few suspicious-looking expressions like myString.length (to get the length of a string) and Math.max (the maximum function) in past examples. These are expressions that access a property of some value. In the first case, we access the length property of the value in myString. In the second, we access the property named max in the Math object (which is a collection of mathematics-related values and functions).Almost all JavaScript values have properties. The exceptions are null and undefined. If you try to access a property on one of these nonvalues, you get an error.null.length;// → TypeError: Cannot read property 'length' of nullThe two most common ways to access properties in JavaScript are with a dot and with square brackets. Both value.x and value[x] access a property on value—but not necessarily the same property. The difference is in how63
x is interpreted. When using a dot, the part after the dot must be a valid variable name, and it directly names the property. When using square brackets, the expression between the brackets is evaluated to get the property name. Whereas value.x fetches the property of value named “x”, value[x] tries to evaluate the expression x and uses the result as the property name.So if you know that the property you are interested in is called “length”, you say value.length. If you want to extract the property named by the value held in the variable i, you say value[i]. And because property names can be any string, if you want to access a property named “2” or “John Doe”, you must use square brackets: value[2] or value["John Doe"]. This is the case even though you know the precise name of the property in advance, because neither “2” nor “John Doe” is a valid variable name and so cannot be accessed through dot notation.The elements in an array are stored in properties. Because the names of these properties are numbers and we often need to get their name from a variable, we have to use the bracket syntax to access them. The length property of an array tells us how many elements it contains. This property name is a valid variable name, and we know its name in advance, so to find the length of an array, you typically write array.length because that is easier to write than array["length"].MethodsBoth string and array objects contain, in addition to the length property, a number of properties that refer to function values.var doh = "Doh";console.log(typeof doh.toUpperCase); // → function console.log(doh.toUpperCase());// → DOHEvery string has a toUpperCase property. When called, it will return a copy of the string, in which all letters have been converted to uppercase. There is also toLowerCase. You can guess what that does.Interestingly, even though the call to toUpperCase does not pass any arguments, the function somehow has access to the string "Doh", the64
value whose property we called. How this works is described in Chapter 6.Properties that contain functions are generally called methods of the value they belong to. As in, “toUpperCase is a method of a string”.This example demonstrates some methods that array objects have:var mack = []; mack.push("Mack"); mack.push("the", "Knife"); console.log(mack);// → ["Mack", "the", "Knife"] console.log(mack.join(" ")); // → Mack the Knife console.log(mack.pop());// → Knife console.log(mack); // → ["Mack", "the"]The push method can be used to add values to the end of an array. The pop method does the opposite: it removes the value at the end of the array and returns it. An array of strings can be flattened to a single string with the join method. The argument given to join determines the text that is glued between the array’s elements.ObjectsBack to the weresquirrel. A set of daily log entries can be represented as an array. But the entries do not consist of just a number or a string— each entry needs to store a list of activities and a Boolean value that indicates whether Jacques turned into a squirrel. Ideally, we would like to group these values together into a single value and then put these grouped values into an array of log entries.Values of the type object are arbitrary collections of properties, and we can add or remove these properties as we please. One way to create an object is by using a curly brace notation.var day1 = {squirrel: false,events: ["work", "touched tree", "pizza", "running",65
"television"]}; console.log(day1.squirrel); // → false console.log(day1.wolf);// → undefinedday1.wolf = false; console.log(day1.wolf);// → falseInside the curly braces, we can give a list of properties separated by commas. Each property is written as a name, followed by a colon, fol- lowed by an expression that provides a value for the property. Spaces and line breaks are not significant. When an object spans multiple lines, indenting it like in the previous example improves readability. Proper- ties whose names are not valid variable names or valid numbers have to be quoted.var descriptions = {work: "Went to work","touched tree": "Touched a tree"};This means that curly braces have two meanings in JavaScript. At the start of a statement, they start a block of statements. In any other position, they describe an object. Fortunately, it is almost never useful to start a statement with a curly-brace object, and in typical programs, there is no ambiguity between these two uses.Reading a property that doesn’t exist will produce the value undefined, as happens the first time we try to read the wolf property in the previous example.It is possible to assign a value to a property expression with the = operator. This will replace the property’s value if it already existed or create a new property on the object if it didn’t.To briefly return to our tentacle model of variable bindings—property bindings are similar. They grasp values, but other variables and proper- ties might be holding onto those same values. You may think of objects as octopuses with any number of tentacles, each of which has a name inscribed on it.66
The delete operator cuts off a leg from such an octopus. It is a unary operator that, when applied to a property access expression, will remove the named property from the object. This is not a common thing to do, but it is possible.var anObject = {left: 1, right: 2}; console.log(anObject.left);// → 1delete anObject.left; console.log(anObject.left);// → undefinedconsole.log("left" in anObject); // → falseconsole.log("right" in anObject); // → trueThe binary in operator, when applied to a string and an object, returns a Boolean value that indicates whether that object has that property. The difference between setting a property to undefined and actually deleting it is that, in the first case, the object still has the property (it just doesn’t have a very interesting value), whereas in the second case the property is no longer present and in will return false.Arrays, then, are just a kind of object specialized for storing sequences of things. If you evaluate typeof [1, 2], this produces "object". You can see them as long, flat octopuses with all their arms in a neat row, labeled with numbers.67
So we can represent Jacques’ journal as an array of objects.var journal = [{events: ["work", "touched tree", "pizza","running", "television"], squirrel: false},{events: ["work", "ice cream", "cauliflower", "lasagna", "touched tree", "brushed teeth"],squirrel: false},{events: ["weekend", "cycling", "break","peanuts", "beer"], squirrel: true},/* and so on ... */ ];MutabilityWe will get to actual programming real soon now. But first, there’s one last piece of theory to understand.We’ve seen that object values can be modified. The types of values discussed in earlier chapters, such as numbers, strings, and Booleans, are all immutable—it is impossible to change an existing value of those types. You can combine them and derive new values from them, but when you take a specific string value, that value will always remain the same. The text inside it cannot be changed. If you have reference to a string that contains "cat", it is not possible for other code to change a68
character in that string to make it spell "rat".With objects, on the other hand, the content of a value can be modifiedby changing its properties.When we have two numbers, 120 and 120, we can consider them pre-cisely the same number, whether or not they refer to the same physical bits. But with objects, there is a difference between having two refer- ences to the same object and having two different objects that contain the same properties. Consider the following code:var object1 = {value: 10}; var object2 = object1;var object3 = {value: 10};console.log(object1 == object2); // → trueconsole.log(object1 == object3); // → falseobject1.value = 15; console.log(object2.value); // → 15 console.log(object3.value); // → 10The object1 and object2 variables grasp the same object, which is why changing object1 also changes the value of object2. The variable object3 points to a different object, which initially contains the same properties as object1 but lives a separate life.JavaScript’s == operator, when comparing objects, will return true only if both objects are precisely the same value. Comparing different objects will return false, even if they have identical contents. There is no “deep” comparison operation built into JavaScript, which looks at object’s con- tents, but it is possible to write it yourself (which will be one of the exercises at the end of this chapter).The lycanthrope’s logSo Jacques starts up his JavaScript interpreter and sets up the environ- ment he needs to keep his journal.69
var journal = [];function addEntry(events , didITurnIntoASquirrel) { journal.push({events: events ,squirrel: didITurnIntoASquirrel });}And then, every evening at ten—or sometimes the next morning, after climbing down from the top shelf of his bookcase—he records the day.addEntry(["work", "touched tree", "pizza", "running", "television"], false);addEntry(["work", "ice cream", "cauliflower", "lasagna", "touched tree", "brushed teeth"], false); addEntry(["weekend", "cycling", "break", "peanuts","beer"], true);Once he has enough data points, he intends to compute the correlation between his squirrelification and each of the day’s events and ideally learn something useful from those correlations.Correlation is a measure of dependence between variables (“variables” in the statistical sense, not the JavaScript sense). It is usually expressed as a coefficient that ranges from -1 to 1. Zero correlation means the variables are not related, whereas a correlation of one indicates that the two are perfectly related—if you know one, you also know the other. Negative one also means that the variables are perfectly related but that they are opposites—when one is true, the other is false.For binary (Boolean) variables, the phi coefficient (φ) provides a good measure of correlation and is relatively easy to compute. To compute φ, we need a table n that contains the number of times the various combinations of the two variables were observed. For example, we could take the event of eating pizza and put that in a table like this:70
No pizza, no squirrel 76Pizza, no squirrel9No pizza, squirrel4Pizza, squirrel1φ can be computed using the following formula, where n refers to the table:n11n00 − n10n01φ= √n n n n (4.1)1• 0• •1 •0The notation n01 indicates the number of measurements where the first variable (squirrelness) is false (0) and the second variable (pizza) is true (1). In this example, n01 is 9.The value n1• refers to the sum of all measurements where the first variable is true, which is 5 in the example table. Likewise, n•0 refers to the sum of the measurements where the second variable is false.So for the pizza table, the part above the division line (the dividend) would be 1×76 - 4×9 = 40, and the part below it (the divisor) would be the square root of 5×85×10×80, or √340000. This comes out to φ ≈ 0.069, which is tiny. Eating pizza does not appear to have influence on the transformations.Computing correlationWe can represent a two-by-two table in JavaScript with a four-element array ([76, 9, 4, 1]). We could also use other representations, such as an array containing two two-element arrays ([[76, 9], [4, 1]]) or an ob- ject with property names like "11" and "01", but the flat array is simple and makes the expressions that access the table pleasantly short. We’ll71
interpret the indices to the array as two-bit binary number, where the leftmost (most significant) digit refers to the squirrel variable and the rightmost (least significant) digit refers to the event variable. For exam- ple, the binary number 10 refers to the case where Jacques did turn into a squirrel, but the event (say, ”pizza”) didn’t occur. This happened four times. And since binary 10 is 2 in decimal notation, we will store this number at index 2 of the array.This is the function that computes the φ coefficient from such an array:function phi(table) {return (table[3] * table[0] - table[2] * table[1]) /Math.sqrt((table[2] + table[3]) * (table[0] + table[1]) * (table[1] + table[3]) * (table[0] + table[2]));}console.log(phi([76, 9, 4, 1]));// → 0.068599434This is simply a direct translation of the φ formula into JavaScript. Math .sqrt is the square root function, as provided by the Math object in a standard JavaScript environment. We have to sum two fields from the table to get fields like n1• because the sums of rows or columns are not stored directly in our data structure.Jacques kept his journal for three months. The resulting data set is available in the coding sandbox for this chapter(eloquentjavascript.net/code#4), where it is stored in the JOURNAL variable, and in a downloadable file.To extract a two-by-two table for a specific event from this journal, we must loop over all the entries and tally up how many times the event occurs in relation to squirrel transformations.function return}hasEvent(event , entry) { entry.events.indexOf(event) != -1;tableFor(event , journal) { var entry = journal[i], index = 0;72functionvar table = [0, 0, 0, 0];for (var i = 0; i < journal.length; i++) {
if (hasEvent(event , entry)) index += 1; if (entry.squirrel) index += 2; table[index] += 1;}return table; }console.log(tableFor("pizza", JOURNAL)); //→ [76,9,4,1]The hasEvent function tests whether an entry contains a given event. Arrays have an indexOf method that tries to find a given value (in this case, the event name) in the array and returns the index at which it was found or -1 if it wasn’t found. So if the call to indexOf doesn’t return -1, then we know the event was found in the entry.The body of the loop in tableFor figures out which box in the table each journal entry falls into by checking whether the entry contains the specific event it’s interested in and whether the event happens alongside a squirrel incident. The loop then adds one to the number in the array that corresponds to this box on the table.We now have the tools we need to compute individual correlations. The only step remaining is to find a correlation for every type of event that was recorded and see whether anything stands out. But how should we store these correlations once we compute them?Objects as mapsOne possible way is to store all the correlations in an array, using objects with name and value properties. But that makes looking up the correlation for a given event somewhat cumbersome: you’d have to loop over the whole array to find the object with the right name. We could wrap this lookup process in a function, but we would still be writing more code, and the computer would be doing more work than necessary.A better way is to use object properties named after the event types. We can use the square bracket access notation to create and read the properties and can use the in operator to test whether a given property exists.73
var map = {};function storePhi(event , phi) {map[event] = phi; }storePhi("pizza", 0.069); storePhi("touched tree", -0.081); console.log("pizza" in map);// → true console.log(map["touched tree"]); // → -0.081A map is a way to go from values in one domain (in this case, event names) to corresponding values in another domain (in this case, φ coef- ficients).There are a few potential problems with using objects like this, which we will discuss in Chapter 6, but for the time being, we won’t worry about those.What if we want to find all the events for which we have stored a coefficient? The properties don’t form a predictable series, like they would in an array, so we can not use a normal for loop. JavaScript provides a loop construct specifically for going over the properties of an object. It looks a little like a normal for loop but distinguishes itself by the use of the word in.for (var event in map)console.log("The correlation for '" + event +"' is " + map[event]);// → The correlation for 'pizza' is 0.069// → The correlation for 'touched tree' is -0.081The final analysisTo find all the types of events that are present in the data set, we simply process each entry in turn and then loop over the events in that entry. We keep an object phis that has correlation coefficients for all the event types we have seen so far. Whenever we run across a type that isn’t in the phis object yet, we compute its correlation and add it to the object.74
function gatherCorrelations(journal) {var phis = {};for (var entry = 0; entry < journal.length; entry++) {var events = journal[entry].events;for (var i = 0; i < events.length; i++) {var event = events[i]; if (!(event in phis))phis[event] = phi(tableFor(event , journal)); }}return phis; }var correlations = gatherCorrelations(JOURNAL); console.log(correlations.pizza);// → 0.068599434Let’s see what came out.for (var event in correlations)console.log(event + ": " + correlations[event]);// → carrot: 0.0140970969// → exercise: 0.0685994341// → weekend: 0.1371988681// → bread: -0.0757554019// → pudding: -0.0648203724// and so on ...Most correlations seem to lie close to zero. Eating carrots, bread, or pudding apparently does not trigger squirrel-lycanthropy. It does seem to occur somewhat more often on weekends, however. Let’s filter the results to show only correlations greater than 0.1 or less than -0.1.for (var event in correlations) {var correlation = correlations[event];if (correlation > 0.1 || correlation < -0.1)console.log(event + ": " + correlation); }// → weekend: 0.1371988681 // → brushed teeth: -0.3805211953// → candy:// → work:// → spaghetti:0.1296407447 -0.1371988681 0.242535625075
// → reading: 0.1106828054 // → peanuts: 0.5902679812A-ha! There are two factors whose correlation is clearly stronger than the others. Eating peanuts has a strong positive effect on the chance of turning into a squirrel, whereas brushing his teeth has a significant negative effect.Interesting. Let’s try something.for (var i = 0; i < JOURNAL.length; i++) { var entry = JOURNAL[i];if (hasEvent("peanuts", entry) &&!hasEvent("brushed teeth", entry)) entry.events.push("peanut teeth");}console.log(phi(tableFor("peanut teeth", JOURNAL))); // → 1Well, that’s unmistakable! The phenomenon occurs precisely when Jacques eats peanuts and fails to brush his teeth. If only he weren’t such a slob about dental hygiene, he’d have never even noticed his affliction.Knowing this, Jacques simply stops eating peanuts altogether and finds that this completely puts an end to his transformations.All is well with Jacques for a while. But a few years later, he loses his job and is eventually forced to take employment with a circus, where he performs as The Incredible Squirrelman by stuffing his mouth with peanut butter before every show. One day, fed up with this pitiful exis- tence, Jacques fails to change back into his human form, hops through a crack in the circus tent, and vanishes into the forest. He is never seen again.Further arrayologyBefore finishing up this chapter, I want to introduce you to a few more object-related concepts. We’ll start by introducing some generally useful array methods.We saw push and pop, which add and remove elements at the end of an array, earlier in this chapter. The corresponding methods for adding and removing things at the start of an array are called unshift and shift.76
var todoList = [];function rememberTo(task) {todoList.push(task); }function whatIsNext() { return todoList.shift();}function urgentlyRememberTo(task) {todoList.unshift(task); }The previous program manages lists of tasks. You add tasks to the end of the list by calling rememberTo("eat"), and when you’re ready to do something, you call whatIsNext() to get (and remove) the front item from the list. The urgentlyRememberTo function also adds a task but adds it to the front instead of the back of the list.The indexOf method has a sibling called lastIndexOf, which starts search- ing for the given element at the end of the array instead of the front.console.log([1, 2, 3, 2, 1].indexOf(2));// → 1console.log([1, 2, 3, 2, 1].lastIndexOf(2)); // → 3Both indexOf and lastIndexOf take an optional second argument that in- dicates where to start searching from.Another fundamental method is slice, which takes a start index and an end index and returns an array that has only the elements between those indices. The start index is inclusive, the end index exclusive.console.log([0, 1, 2, 3, 4].slice(2, 4)); // → [2, 3]console.log([0, 1, 2, 3, 4].slice(2)); //→ [2,3,4]When the end index is not given, slice will take all of the elements after the start index. Strings also have a slice method, which has a similar effect.The concat method can be used to glue arrays together, similar to what the + operator does for strings. The following example shows both concat and slice in action. It takes an array and an index, and it returns a new77
array which is a copy of the original array with the element at the given index removed.function remove(array , index) { return array.slice(0, index).concat(array.slice(index + 1)); }console.log(remove(["a", "b", "c", "d", "e"], 2)); // → ["a", "b", "d", "e"]Strings and their propertiesWe can read properties like length and toUpperCase from string values. But if you try to add a new property, it doesn’t stick.var myString = "Fido"; myString.myProperty = "value"; console.log(myString.myProperty); // → undefinedValues of type string, number, and Boolean are not objects, and though the language doesn’t complain if you try to set new properties on them, it doesn’t actually store those properties. The values are immutable and cannot be changed.But these types do have some built-in properties. Every string value has a number of methods. The most useful ones are probably slice and indexOf, which resemble the array methods of the same name.console.log("coconuts".slice(4, 7)); // → nut console.log("coconut".indexOf("u")); // → 5One difference is that a string’s indexOf can take a string containing more than one character, whereas the corresponding array method looks only for a single element.console.log("one two three".indexOf("ee")); // → 1178
The trim method removes whitespace (spaces, newlines, tabs, and similar characters) from the start and end of a string.console.log(" okay \n ".trim()); // → okayWe have already seen the string type’s length property. Accessing the individual characters in a string can be done with the charAt method but also by simply reading numeric properties, like you’d do for an array.var string = "abc"; console.log(string.length);// → 3 console.log(string.charAt(0)); // → aconsole.log(string[1]);// → bThe arguments objectWhenever a function is called, a special variable named arguments is added to the environment in which the function body runs. This variable refers to an object that holds all of the arguments passed to the function. Remember that in JavaScript you are allowed to pass more (or fewer) arguments to a function than the number of parameters the function itself declares.function noArguments () {} noArguments(1, 2, 3); // This is okay function threeArguments(a, b, c) {} threeArguments(); // And so is thisThe arguments object has a length property that tells us the number of arguments that were really passed to the function. It also has a property for each argument, named 0, 1, 2, and so on.If that sounds a lot like an array to you, you’re right, it is a lot like an array. But this object, unfortunately, does not have any array methods (like slice or indexOf), so it is a little harder to use than a real array.function argumentCounter() {79
console.log("You gave me", arguments.length, "arguments."); }argumentCounter("Straw man", "Tautology", "Ad hominem"); // → You gave me 3 arguments.Some functions can take any number of arguments, like console.log. These typically loop over the values in their arguments object. They can be used to create very pleasant interfaces. For example, remember how we created the entries to Jacques’ journal.addEntry(["work", "touched tree", "pizza", "running", "television"], false);Since he is going to be calling this function a lot, we could create an alternative that is easier to call.function addEntry(squirrel) {var entry = {events: [], squirrel: squirrel}; for (var i = 1; i < arguments.length; i++)entry.events.push(arguments[i]); journal.push(entry);}addEntry(true, "work", "touched tree", "pizza","running", "television");This version reads its first argument (squirrel) in the normal way and then goes over the rest of the arguments (the loop starts at index 1, skipping the first) to gather them into an array.The Math objectAs we’ve seen, Math is a grab-bag of number-related utility functions, such as Math.max (maximum), Math.min (minimum), and Math.sqrt (square root).The Math object is used simply as a container to group a bunch of related functionality. There is only one Math object, and it is almost never useful as a value. Rather, it provides a namespace so that all these functions and values do not have to be global variables.Having too many global variables “pollutes” the namespace. The more names that have been taken, the more likely you are to accidentally80
overwrite the value of some variable. For example, it’s not unlikely that you’ll want to name something max in one of your programs. Since JavaScript’s built-in max function is tucked safely inside the Math object, we don’t have to worry about overwriting it.Many languages will stop you, or at least warn you, when you are defining a variable with a name that is already taken. JavaScript does neither, so be careful.Back to the Math object. If you need to do trigonometry, Math can help. It contains cos (cosine), sin (sine), and tan (tangent), as well as their inverse functions, acos, asin, and atan. The number π (pi)—or at least the closest approximation that fits in a JavaScript number—is available as Math.PI. (There is an old programming tradition of writing the names of constant values in all caps.)function randomPointOnCircle(radius) {var angle = Math.random() * 2 * Math.PI; return {x: radius * Math.cos(angle),y: radius * Math.sin(angle)}; console.log(randomPointOnCircle(2));}// → {x: 0.3667 , y: 1.966}If sines and cosines are not something you are very familiar with, don’t worry. When they are used in this book, in Chapter 13, I’ll explain them. The previous example uses Math.random. This is a function that returns a new pseudo-random number between zero (inclusive) and one (exclusive)every time you call it.console.log(Math.random()); // → 0.36993729369714856 console.log(Math.random()); // → 0.727367032552138 console.log(Math.random()); // → 0.40180766698904335Though computers are deterministic machines—they always react the same way if given the same input— it is possible to have them produce numbers that appear random. To do this, the machine keeps a num- ber (or a bunch of numbers) in its internal state. Then, every time a random number is requested, it performs some complicated determinis-81
tic computations on this internal state and returns part of the result of those computations. The machine also uses the outcome to change its own internal state so that the next ”random” number produced will be different.If we want a whole random number instead of a fractional one, we can use Math.floor (which rounds down to the nearest whole number) on the result of Math.random.console.log(Math.floor(Math.random() * 10)); // → 2Multiplying the random number by ten gives us a number greater than or equal to zero, and below ten. Since Math.floor rounds down, this expression will produce, with equal chance, any number from 0 through 9.There are also the functions Math.ceil (for ”ceiling”, which rounds up to a whole number) and Math.round (to the nearest whole number).The global objectThe global scope, the space in which global variables live, can also be approached as an object in JavaScript. Each global variable is present as a property of this object. In browsers, the global scope object is stored in the window variable.var myVar = 10; console.log("myVar" in window); // → true console.log(window.myVar);// → 10SummaryObjects and arrays (which are a specific kind of object) provide ways to group several values into a single value. Conceptually, this allows us to put a bunch of related things in a bag and run around with the bag,82
instead of trying to wrap our arms around all of the individual things and trying to hold on to them separately.Most values in JavaScript have properties, the exceptions being null and undefined. Properties are accessed using value.propName or value[" propName"]. Objects tend to use names for their properties and store more or less a fixed set of them. Arrays, on the other hand, usually con- tain varying numbers of conceptually identical values and use numbers(starting from 0) as the names of their properties.There are some named properties in arrays, such as length and a numberof methods. Methods are functions that live in properties and (usually) act on the value they are a property of.Objects can also serve as maps, associating values with names. The in operator can be used to find out whether an object contains a property with a given name. The same keyword can also be used in a for loop (for (var name in object)) to loop over an object’s properties.ExercisesThe sum of a rangeThe introduction of this book alluded to the following as a nice way to compute the sum of a range of numbers:console.log(sum(range(1, 10)));Write a range function that takes two arguments, start and end, and returns an array containing all the numbers from start up to (and in- cluding) end.Next, write a sum function that takes an array of numbers and returns the sum of these numbers. Run the previous program and see whether it does indeed return 55.As a bonus assignment, modify your range function to take an optional third argument that indicates the “step” value used to build up the array. If no step is given, the array elements go up by increments of one, corresponding to the old behavior. The function call range(1, 10, 2) should return [1, 3, 5, 7, 9]. Make sure it also works with negative step values so that range(5, 2, -1) produces [5, 4, 3, 2].83
Reversing an arrayArrays have a method reverse, which changes the array by inverting the order in which its elements appear. For this exercise, write two functions, reverseArray and reverseArrayInPlace. The first, reverseArray, takes an array as argument and produces a new array that has the same elements in the inverse order. The second, reverseArrayInPlace, does what the reverse method does: it modifies the array given as argument in order to reverse its elements. Neither may use the standard reverse method.Thinking back to the notes about side effects and pure functions in the previous chapter, which variant do you expect to be useful in more situations? Which one is more efficient?A listObjects, as generic blobs of values, can be used to build all sorts of data structures. A common data structure is the list (not to be confused with the array). A list is a nested set of objects, with the first object holding a reference to the second, the second to the third, and so on.var list = { value: 1, rest: {value: 2, rest: {value: 3,rest: null }} };The resulting objects form a chain, like this:value: 1 value: 2rest: rest: value: 3rest: nullA nice thing about lists is that they can share parts of their structure. For example, if I create two new values {value: 0, rest: list} and {value: -1, rest: list} (with list referring to the variable defined earlier), they84
are both independent lists, but they share the structure that makes up their last three elements. In addition, the original list is also still a valid three-element list.Write a function arrayToList that builds up a data structure like the previous one when given [1, 2, 3] as argument, and write a listToArray function that produces an array from a list. Also write the helper functions prepend, which takes an element and a list and creates a new list that adds the element to the front of the input list, and nth, which takes a list and a number and returns the element at the given positionin the list, or undefined when there is no such element.If you haven’t already, also write a recursive version of nth.Deep comparisonThe == operator compares objects by identity. But sometimes, you would prefer to compare the values of their actual properties.Write a function, deepEqual, that takes two values and returns true only if they are the same value or are objects with the same properties whose values are also equal when compared with a recursive call to deepEqual.To find out whether to compare two things by identity (use the === operator for that) or by looking at their properties, you can use the typeof operator. If it produces "object" for both values, you should do a deep comparison. But you have to take one silly exception into account:by a historical accident, typeof null also produces "object".85
