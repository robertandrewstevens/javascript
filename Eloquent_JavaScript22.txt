Exercise HintsThe hints below might help when you are stuck with one of the exercises in this book. They don’t give away the entire solution, but rather try to help you find it yourself.Program Structure Looping a triangleYou can start with a program that simply prints out the numbers 1 to 7, which you can derive by making a few modifications to the even- number-printing example given earlier in the chapter, where the for loop was introduced.Now consider the equivalence between numbers and strings of hash characters. You can go from 1 to 2 by adding 1 (+= 1). You can go from "\#" to "\#\#" by adding a character (+= "\#"). Thus, your solution can closely follow the number-printing program.FizzBuzzGoing over the numbers is clearly a looping job, and selecting what to print is a matter of conditional execution. Remember the trick of using the remainder (%) operator for checking whether a number is divisible by another number (has a remainder of zero).In the first version, there are three possible outcomes for every number, so you’ll have to create an if/else if/else chain.The second version of the program has a straightforward solution and a clever one. The simple way is to add another “branch” to precisely test the given condition. For the clever method, build up a string containing the word or words to output, and print either this word or the number if there is no word, potentially by making elegant use of the || operator.424
Chess boardThe string can be built by starting with an empty one ("") and repeatedly adding characters. A newline character is written "\n".Use console.log to inspect the output of your program.To work with two dimensions, you will need a loop inside of a loop. Put curly braces around the bodies of both loops to make it easy to see where they start and end. Try to properly indent these bodies. The order of the loops must follow the order in which we build up the string (line by line, left to right, top to bottom). So the outer loop handles the lines and the inner loop handles the characters on a line.You’ll need two variables to track your progress. To know whether to put a space or a hash sign at a given position, you could test whether the sum of the two counters is even (% 2).Terminating a line by adding a newline character happens after the line has been built up, so do this after the inner loop but inside of the outer loop.Functions MinimumIf you have trouble putting braces and parentheses in the right place to get a valid function definition, start by copying one of the examples in this chapter and modifying it.A function may contain multiple return statements. RecursionYour function will likely look somewhat similar to the inner find function in the recursive findSolution example in this chapter, with an if/else if /else chain that tests which of the three cases applies. The final else, corresponding to the third case, makes the recursive call. Each of the branches should contain a return statement or in some other way arrange for a specific value to be returned.When given a negative number, the function will recurse again and again, passing itself an ever more negative number, thus getting further425
and further away from returning a result. It will eventually run out of stack space and abort.Bean countingA loop in your function will have to look at every character in the string by running an index from zero to one below its length (< string.length ). If the character at the current position is the same as the one the function is looking for, it adds 1 to a counter variable. Once the loop has finished, the counter can be returned.Take care to make all the variables used in the function local to the function by using the var keyword.Data Structures: Objects and Arrays The sum of a rangeBuilding up an array is most easily done by first initializing a variable to [] (a fresh, empty array) and repeatedly calling its push method to add a value. Don’t forget to return the array at the end of the function.Since the end boundary is inclusive, you’ll need to use the <= operator rather than simply < to check for the end of your loop.To check whether the optional step argument was given, either check arguments.length or compare the value of the argument to undefined. If it wasn’t given, simply set it to its default value (1) at the top of the function.Having range understand negative step values is probably best done by writing two separate loops—one for counting up and one for counting down—because the comparison that checks whether the loop is finished needs to be >= rather than <= when counting downward.It might also be worthwhile to use a different default step, namely, -1, when the end of the range is smaller than the start. That way, range(5, 2) returns something meaningful, rather than getting stuck in an infinite loop.426
Reversing an arrayThere are two obvious ways to implement reverseArray. The first is to simply go over the input array from front to back and use the unshift method on the new array to insert each element at its start. The second is to loop over the input array backward and use the push method. Iterating over an array backward requires a (somewhat awkward) for specification like (var i = array.length - 1; i >= 0; i--).Reversing the array in place is harder. You have to be careful not to overwrite elements that you will later need. Using reverseArray or otherwise copying the whole array (array.slice(0) is a good way to copy an array) works but is cheating.The trick is to swap the first and last elements, then the second and second-to-last, and so on. You can do this by looping over half the length of the array (use Math.floor to round down—you don’t need to touch the middle element in an array with an odd length) and swapping the element at position i with the one at position array.length - 1 - i. You can use a local variable to briefly hold on to one of the elements, overwrite that one with its mirror image, and then put the value from the local variable in the place where the mirror image used to be.A listBuilding up a list is best done back to front. So arrayToList could iterate over the array backward (see previous exercise) and, for each element, add an object to the list. You can use a local variable to hold the part of the list that was built so far and use a pattern like list = {value: X, rest: list} to add an element.To run over a list (in listToArray and nth), a for loop specification like this can be used:for (var node = list; node; node = node.rest) {}Can you see how that works? Every iteration of the loop, node points to the current sublist, and the body can read its value property to get the current element. At the end of an iteration, node moves to the next sublist. When that is null, we have reached the end of the list and the loop is finished.427
The recursive version of nth will, similarly, look at an ever smaller part of the “tail” of the list and at the same time count down the index until it reaches zero, at which point it can return the value property of the node it is looking at. To get the zeroeth element of a list, you simply take the value property of its head node. To get element N + 1, you take the Nth element of the list that’s in this list’s rest property.Deep comparisonYour test for whether you are dealing with a real object will look some- thing like typeof x == "object" && x != null. Be careful to compare prop- erties only when both arguments are objects. In all other cases you can just immediately return the result of applying ===.Use a for/in loop to go over the properties. You need to test whether both objects have the same set of property names and whether those properties have identical values. The first test can be done by count- ing the properties in both objects and returning false if the numbers of properties are different. If they’re the same, then go over the properties of one object, and for each of them, verify that the other object also has the property. The values of the properties are compared by a recursive call to deepEqual.Returning the correct value from the function is best done by immedi- ately returning false when a mismatch is noticed and returning true at the end of the function.Higher-Order Functions Mother-child age differenceBecause not all elements in the ancestry array produce useful data (we can’t compute the age difference unless we know the birth date of the mother), we will have to apply filter in some manner before calling average. You could do it as a first pass, by defining a hasKnownMother function and filtering on that first. Alternatively, you could start by calling map and in your mapping function return either the age difference or null if no mother is known. Then, you can call filter to remove the428
null elements before passing the array to average. Historical life expectancyThe essence of this example lies in grouping the elements of a collection by some aspect of theirs—splitting the array of ancestors into smaller arrays with the ancestors for each century.During the grouping process, keep an object that associates century names (numbers) with arrays of either person objects or ages. Since we do not know in advance what categories we will find, we’ll have to create them on the fly. For each person, after computing their century, we test whether that century was already known. If not, add an array for it. Then add the person (or age) to the array for the proper century.Finally, a for/in loop can be used to print the average ages for the individual centuries.Every and then someThe functions can follow a similar pattern to the definition of forEach at the start of the chapter, except that they must return immediately (with the right value) when the predicate function returns false—or true. Don’t forget to put another return statement after the loop so that the function also returns the correct value when it reaches the end of the array.The Secret Life of Objects A vector typeYour solution can follow the pattern of the Rabbit constructor from this chapter quite closely.Adding a getter property to the constructor can be done with the Object.defineProperty function. To compute the distance from (0, 0) to (x, y),you can use the Pythagorean theorem, which says that the square of thedistance we are looking for is equal to the square of the x coordinateplus the square of the y coordinate. Thus, x2 + y2 is the number you want, and Math.sqrt is the way you compute a square root in JavaScript.429√
Another cellYou’ll have to store all three constructor arguments in the instance ob- ject. The minWidth and minHeight methods should call through to the corresponding methods in the inner cell but ensure that no number less than the given size is returned (possibly using Math.max).Don’t forget to add a draw method that simply forwards the call to the inner cell.Sequence interfaceOne way to solve this is to give the sequence objects state, meaning their properties are changed in the process of using them. You could store a counter that indicates how far the sequence object has advanced.Your interface will need to expose at least a way to get the next element and to find out whether the iteration has reached the end of the sequence yet. It is tempting to roll these into one method, next, which returns null or undefined when the sequence is at its end. But now you have a problem when a sequence actually contains null. So a separate method (or getter property) to find out whether the end has been reached is probably preferable.Another solution is to avoid changing state in the object. You can expose a method for getting the current element (without advancing any counter) and another for getting a new sequence that represents the remaining elements after the current one (or a special value if the end of the sequence is reached). This is quite elegant—a sequence value will “stay itself” even after it is used and can thus be shared with other code without worrying about what might happen to it. It is, unfortunately, also somewhat inefficient in a language like JavaScript because it involves creating a lot of objects during iteration.Project: Electronic Life Artificial stupidityThe greediness problem can be attacked in several ways. The critters could stop eating when they reach a certain energy level. Or they could430
eat only every N turns (by keeping a counter of the turns since their last meal in a property on the creature object). Or, to make sure plants never go entirely extinct, the animals could refuse to eat a plant unless they see at least one other plant nearby (using the findAll method on the view). A combination of these, or some entirely different strategy, might also work.Making the critters move more effectively could be done by stealing one of the movement strategies from the critters in our old, energyless world. Both the bouncing behavior and the wall-following behavior showed a much wider range of movement than completely random staggering.Making creatures breed more slowly is trivial. Just increase the min- imum energy level at which they reproduce. Of course, making the ecosystem more stable also makes it more boring. If you have a handful of fat, immobile critters forever munching on a sea of plants and never reproducing, that makes for a very stable ecosystem. But no one wants to watch that.PredatorsMany of the same tricks that worked for the previous exercise also ap- ply here. Making the predators big (lots of energy) and having them reproduce slowly is recommended. That’ll make them less vulnerable to periods of starvation when the herbivores are scarce.Beyond staying alive, keeping its food stock alive is a predator’s main objective. Find some way to make predators hunt more aggressively when there are a lot of herbivores and hunt more slowly (or not at all) when prey is rare. Since plant eaters move around, the simple trick of eating one only when others are nearby is unlikely to work—that’ll happen so rarely that your predator will starve. But you could keep track of observations in previous turns, in some data structure kept on the predator objects, and have it base its behavior on what it has seen recently.431
Bugs and Error Handling RetryThe call to primitiveMultiply should obviously happen in a try block. The corresponding catch block should rethrow the exception when it is not an instance of MultiplicatorUnitFailure and ensure the call is retried when it is.To do the retrying, you can either use a loop that breaks only when a call succeeds—as in the look example earlier in this chapter—or use recursion and hope you don’t get a string of failures so long that it overflows the stack (which is a pretty safe bet).The locked boxThis exercise calls for a finally block, as you probably guessed. Your function should first unlock the box and then call the argument function from inside a try body. The finally block after it should lock the box again.To make sure we don’t lock the box when it wasn’t already locked, check its lock at the start of the function and unlock and lock it only when it started out locked.Regular Expressions Quoting styleThe most obvious solution is to only replace quotes with a nonword character on at least one side. Something like /\W'|'\W/. But you also have to take the start and end of the line into account.In addition, you must ensure that the replacement also includes the characters that were matched by the \W pattern so that those are not dropped. This can be done by wrapping them in parentheses and in- cluding their groups in the replacement string ($1, $2). Groups that are not matched will be replaced by nothing.432
Numbers againFirst, do not forget the backslash in front of the dot.Matching the optional sign in front of the number, as well as in frontof the exponent, can be done with [+\-]? or (\+|-|) (plus, minus, or nothing).The more complicated part of the exercise is the problem of matching both "5." and ".5" without also matching ".". For this, a good solution is to use the | operator to separate the two cases—either one or more digits optionally followed by a dot and zero or more digits or a dot followed by one or more digits.Finally, to make the e case-insensitive, either add an i option to the regular expression or use [eE].Modules Month namesThis follows the weekDay module almost exactly. A function expression, called immediately, wraps the variable that holds the array of names, along with the two functions that must be exported. The functions are put in an object and returned. The returned interface object is stored in the month variable.A return to electronic lifeHere is what I came up with. I’ve put parentheses around internal func- tions.Module "grid" VectorGrid directions directionNamesModule "world" (randomElement) (elementFromChar) (charFromElement)433
ViewWorldLifelikeWorld directions [reexported]Module "simple_ecosystem" (randomElement) [duplicated] (dirPlus)WallBouncingCritter WallFollowerModule "ecosystem" Wall [duplicated] PlantPlantEater SmartPlantEater TigerI have reexported the directions array from the grid module from world so that modules built on that (the ecosystems) don’t have to know or worry about the existence of the grid module.I also duplicated two generic and tiny helper values (randomElement and Wall) since they are used as internal details in different contexts and do not belong in the interfaces for these modules.Circular dependenciesThe trick is to add the exports object created for a module to require’s cache before actually running the module. This means the module will not yet have had a chance to override module.exports, so we do not know whether it may want to export some other value. After loading, the cache object is overridden with module.exports, which may be a different value.But if in the course of loading the module, a second module is loaded that asks for the first module, its default exports object, which is likely still empty at this point, will be in the cache, and the second module will receive a reference to it. If it doesn’t try to do anything with the object until the first module has finished loading, things will work.434
Project: A Programming Language ArraysThe easiest way to do this is to represent Egg arrays with JavaScript arrays.The values added to the top environment must be functions. Array. prototype.slice can be used to convert an arguments array-like object into a regular array.ClosureAgain, we are riding along on a JavaScript mechanism to get the equiv- alent feature in Egg. Special forms are passed the local environment in which they are evaluated so that they can evaluate their subforms in that environment. The function returned by fun closes over the env argument given to its enclosing function and uses that to create the function’s local environment when it is called.This means that the prototype of the local environment will be the environment in which the function was created, which makes it possible to access variables in that environment from the function. This is all there is to implementing closure (though to compile it in a way that is actually efficient, you’d need to do some more work).CommentsMake sure your solution handles multiple comments in a row, with po- tentially whitespace between or after them.A regular expression is probably the easiest way to solve this. Write something that matches “whitespace or a comment, zero or more times”. Use the exec or match method and look at the length of the first element in the returned array (the whole match) to find out how many characters to slice off.435
Fixing scopeYou will have to loop through one scope at a time, using Object.getPrototypeOf to go the next outer scope. For each scope, use hasOwnProperty to find out whether the variable, indicated by the name property of the first argumentto set, exists in that scope. If it does, set it to the result of evaluatingthe second argument to set and then return that value.If the outermost scope is reached (Object.getPrototypeOf returns null) and we haven’t found the variable yet, it doesn’t exist, and an errorshould be thrown.The Document Object Model Build a tableUse document.createElement to create new element nodes, document.createTextNode to create text nodes, and the appendChild method to put nodes into othernodes.You should loop over the key names once to fill in the top row andthen again for each object in the array to construct the data rows. Don’t forget to return the enclosing <table> element at the end of thefunction.Elements by tag nameThe solution is most easily expressed with a recursive function, similar to the talksAbout function defined earlier in this chapter.You could call byTagname itself recursively, concatenating the resulting arrays to produce the output. For a more efficient approach, define an inner function that calls itself recursively and that has access to an array variable defined in the outer function to which it can add the matching elements it finds. Don’t forget to call the inner function once from the outer function.The recursive function must check the node type. Here we are inter- ested only in node type 1 (document.ELEMENT_NODE). For such nodes, we must loop over their children and, for each child, see whether the child436
matches the query while also doing a recursive call on it to inspect its own children.Handling Events Censored keyboardThe solution to this exercise involves preventing the default behavior of key events. You can handle either "keypress" or "keydown". If either of them has preventDefault called on it, the letter will not appear.Identifying the letter typed requires looking at the keyCode or charCode property and comparing that with the codes for the letters you want to filter. In "keydown", you do not have to worry about lowercase and uppercase letters, since it identifies only the key pressed. If you decide to handle "keypress" instead, which identifies the actual character typed, you have to make sure you test for both cases. One way to do that would be this:/[qwx]/i.test(String.fromCharCode(event.charCode))Mouse trailCreating the elements is best done in a loop. Append them to the document to make them show up. To be able to access them later to change their position, store the trail elements in an array.Cycling through them can be done by keeping a counter variable and adding 1 to it every time the "mousemove" event fires. The remainder operator (% 10) can then be used to get a valid array index to pick the element you want to position during a given event.Another interesting effect can be achieved by modeling a simple physics system. Use the "mousemove" event only to update a pair of variables that track the mouse position. Then use requestAnimationFrame to simulate the trailing elements being attracted to the position of the mouse pointer. At every animation step, update their position based on their position relative to the pointer (and, optionally, a speed that is stored for each element). Figuring out a good way to do this is up to you.437
TabsOne pitfall you’ll probably run into is that you can’t directly use the node’s childNodes property as a collection of tab nodes. For one thing, when you add the buttons, they will also become child nodes and end up in this object because it is live. For another, the text nodes created for the whitespace between the nodes are also in there and should not get their own tabs.To work around this, start by building up a real array of all the children in the wrapper that have a nodeType of 1.When registering event handlers on the buttons, the handler functions will need to know which tab element is associated with the button. If they are created in a normal loop, you can access the loop index vari- able from inside the function, but it won’t give you the correct number because that variable will have been further changed by the loop.A simple workaround is to use the forEach method and create the han- dler functions from inside the function passed to forEach. The loop index, which is passed as a second argument to that function, will be a normal local variable there and won’t be overwritten by further iterations.Project: A Platform Game Game overThe most obvious solution would be to make lives a variable that lives in runGame and is thus visible to the startLevel closure.Another approach, which fits nicely with the spirit of the rest of the function, would be to add a second parameter to startLevel that gives the number of lives. When the whole state of a system is stored in the arguments to a function, calling that function provides an elegant way to transition to a new state.In any case, when a level is lost, there should now be two possible state transitions. If that was the last life, we go back to level zero with the starting amount of lives. If not, we repeat the current level with one less life remaining.438
Pausing the gameAn animation can be interrupted by returning false from the function given to runAnimation. It can be continued by calling runAnimation again.To communicate that the animation should be interrupted to the func- tion passed to runAnimation so that it can return false, you can use a variable that both the event handler and that function have access to.When finding a way to unregister the handlers registered by trackKeys , remember that the exact same function value that was passed to addEventListener must be passed to removeEventListener to successfully re- move a handler. Thus, the handler function value created in trackKeys must be available to the code that unregisters the handlers.You can add a property to the object returned by trackKeys, containing either that function value or a method that handles the unregistering directly.Drawing on Canvas ShapesThe trapezoid (1) is easy to draw using a path. Pick suitable center coordinates and add each of the four corners around that.The diamond (2) can be drawn the easy way, with a path, or the inter- esting way, with a rotate transformation. To use rotation, you will have to apply a trick similar to what we did in the flipHorizontally function. Because you want to rotate around the center of your rectangle and not around the point (0,0), you must first translate to there, then rotate, and then translate back.For the zigzag (3) it becomes impractical to write a new call to lineTo for each line segment. Instead, you should use a loop. You can have each iteration draw either two line segments (right and then left again) or one, in which case you must use the evenness (% 2) of the loop index to determine whether to go left or right.You’ll also need a loop for the spiral (4). If you draw a series of points, with each point moving further along a circle around the spiral’s center, you get a circle. If, during the loop, you vary the radius of the circle on439
which you are putting the current point and go around more than once, the result is a spiral.The star (5) depicted is built out of quadraticCurveTo lines. You could also draw one with straight lines. Divide a circle into eight pieces, or a piece for each point you want your star to have. Draw lines between these points, making them curve toward the center of the star. With quadraticCurveTo, you can use the center as the control point.The pie chartYou will need to call fillText and set the context’s textAlign and textBaseline properties in such a way that the text ends up where you want it.A sensible way to position the labels would be to put the text on the line going from the center of the pie through the middle of the slice. You don’t want to put the text directly against the side of the pie but rather move the text out to the side of the pie by a given number of pixels.The angle of this line is currentAngle + 0.5 * sliceAngle. The following code finds a position on this line, 120 pixels from the center:var middleAngle = currentAngle + 0.5 * sliceAngle; var textX = Math.cos(middleAngle) * 120 + centerX; var textY = Math.sin(middleAngle) * 120 + centerY;For textBaseline, the value "middle" is probably appropriate when using this approach. What to use for textAlign depends on the side of the circle we are on. On the left, it should be "right", and on the right, it should be "left" so that the text is positioned away from the pie.If you are not sure how to find out which side of the circle a given angle is on, look to the explanation of Math.cos in the previous exercise. The cosine of an angle tells us which x coordinate it corresponds to, which in turn tells us exactly which side of the circle we are on.A bouncing ballA box is easy to draw with strokeRect. Define a variable that holds its size or define two variables if your box’s width and height differ. To create a round ball, start a path, call arc(x, y, radius, 0, 7), which creates an arc going from zero to more than a whole circle, and fill it.440
To model the ball’s position and speed, you can use the Vector type from Chapter 15(!interactive (which is available on this page)!). Give it a starting speed, preferably one that is not purely vertical or horizontal, and every frame, multiply that speed with the amount of time that elapsed. When the ball gets too close to a vertical wall, invert the x component in its speed. Likewise, invert the y component when it hits a horizontal wall.After finding the ball’s new position and speed, use clearRect to delete the scene and redraw it using the new position.Precomputed mirroringThe key to the solution is the fact that we can use a canvas element as a source image when using drawImage. It is possible to create an extra <canvas > element, without adding it to the document, and draw our inverted sprites to it, once. When drawing an actual frame, we just copy the already inverted sprites to the main canvas.Some care would be required because images do not load instantly. We do the inverted drawing only once, and if we do it before the image loads, it won’t draw anything. A "load" handler on the image can be used to draw the inverted images to the extra canvas. This canvas can be used as a drawing source immediately (it’ll simply be blank until we draw the character onto it).HTTPContent negotiationSee the various examples of using an XMLHttpRequest in this chapter for an example of the method calls involved in making a request. You can use a synchronous request (by setting the third parameter to open to false) if you want.Asking for a bogus media type will return a response with code 406, “Not acceptable”, which is the code a server should return when it can’t fulfill the Accept header.441
Waiting for multiple promisesThe function passed to the Promise constructor will have to call then on each of the promises in the given array. When one of them succeeds, two things need to happen. The resulting value needs to be stored in the correct position of a result array, and we must check whether this was the last pending promise and finish our own promise if it was.The latter can be done with a counter, which is initialized to the length of the input array and from which we subtract 1 every time a promise succeeds. When it reaches 0, we are done. Make sure you take the situation where the input array is empty (and thus no promise will ever resolve) into account.Handling failure requires some thought but turns out to be extremely simple. Just pass the failure function of the wrapping promise to each of the promises in the array so that a failure in one of them triggers the failure of the whole wrapper.Forms and Form Fields A JavaScript workbenchUse document.querySelector or document.getElementById to get access to the el- ements defined in your HTML. An event handler for "click" or "mousedown" events on the button can get the value property of the text field and call new Function on it.Make sure you wrap both the call to new Function and the call to its result in a try block so that you can catch exceptions that it produces. In this case, we really don’t know what type of exception we are looking for, so catch everything.The textContent property of the output element can be used to fill it with a string message. Or, if you want to keep the old content around, create a new text node using document.createTextNode and append it to the element. Remember to add a newline character to the end so that not all output appears on a single line.442
AutocompletionThe best event for updating the suggestion list is "input" since that will fire immediately when the content of the field is changed.Then loop over the array of terms and see whether they start with the given string. For example, you could call indexOf and see whether the result is zero. For each matching string, add an element to the suggestions <div>. You should probably also empty that each time you start updating the suggestions, for example by setting its textContent to the empty string.You could either add a "click" event handler to every suggestion ele- ment or add a single one to the outer <div> that holds them and look at the target property of the event to find out which suggestion was clicked.To get the suggestion text out of a DOM node, you could look at its textContent or set an attribute to explicitly store the text when you create the element.Conway’s Game of LifeTo solve the problem of having the changes conceptually happen at the same time, try to see the computation of a generation as a pure function, which takes one grid and produces a new grid that represents the next turn.Representing the grid can be done in any of the ways shown in Chapters 7 and 15. Counting live neighbors can be done with two nested loops, looping over adjacent coordinates. Take care not to count cells outside of the field and to ignore the cell in the center, whose neighbors we are counting.Making changes to checkboxes take effect on the next generation can be done in two ways. An event handler could notice these changes and update the current grid to reflect them, or you could generate a fresh grid from the values in the checkboxes before computing the next turn.If you choose to go with event handlers, you might want to attach attributes that identify the position that each checkbox corresponds to so that it is easy to find out which cell to change.To draw the grid of checkboxes, you either can use a <table> element (see Chapter 13) or simply put them all in the same element and put443
<br> (line break) elements between the rows. Project: A Paint ProgramRectanglesYou can use relativePos to find the corner corresponding to the start of the mouse drag. Figuring out where the drag ends can be done with trackDrag or by registering your own event handler.When you have two corners of the rectangle, you must somehow trans- late these into the arguments that fillRect expects: the top-left corner, width, and height of the rectangle. Math.min can be used to find the left- most x coordinate and topmost y coordinate. To get the width or height, you can call Math.abs (the absolute value) on the difference between two sides.Showing the rectangle during the mouse drag requires a similar set of numbers but in the context of the whole page rather than relative to the canvas. Consider writing a function findRect, which converts two points into an object with top, left, width, and height properties so that you don’t have to write the same logic twice.You can then create a <div> node and set its style.position to absolute . When setting positioning styles, do not forget to append "px" to the numbers. The node must be added to the document (you can append it to document.body) and also removed again when the drag ends and the actual rectangle gets drawn onto the canvas.Color pickerYou’ll again need to use relativePos to find out which pixel was clicked. The pixelAt function in the example demonstrates how to get the values for a given pixel. Putting those into an rgb string merely requires some string concatenation.Make sure you verify that the exception you catch is an instance of SecurityError so that you don’t accidentally handle the wrong kind of exception.444
Flood fillGiven a pair of starting coordinates and the image data for the whole canvas, this approach should work:1. Create an array to hold information about already colored coordi- nates.2. Create a work list array to hold coordinates that must be looked at. Put the start position in it.3. When the work list is empty, we are done.4. Remove one pair of coordinates from the work list.5. If those coordinates are already in our array of colored pixels, go back to step 3.6. Color the pixel at the current coordinates and add the coordinates to the array of colored pixels.7. Add the coordinates of each adjacent pixel whose color is the same as the starting pixel’s original color to the work list.8. Return to step 3.The work list can simply be an array of vector objects. The data struc- ture that tracks colored pixels will be consulted very often. Searching through the whole thing every time a new pixel is visited will take a lot of time. You could instead create an array that has a value in it for every pixel, using again the x + y × width scheme for associating positions with pixels. When checking whether a pixel has been colored already, you could directly access the field corresponding to the current pixel.You can compare colors by running over the relevant part of the data array, comparing one field at a time. Or you can “condense” a color to a single number or string and compare those. When doing this, ensure that every color produces a unique value. For example, simply adding the color’s components is not safe since multiple colors will have the same sum.445
When enumerating the neighbors of a given point, take care to exclude neighbors that are not inside of the canvas or your program might run off into one direction forever.Node.jsContent negotiation, againDon’t forget to call the end method on the object returned by http.request in order to actually fire off the request.The response object passed to http.request’s callback is a readable stream. This means that it is not entirely trivial to get the whole re- sponse body from it. The following utility function reads a whole stream and calls a callback function with the result, using the usual pattern of passing any errors it encounters as the first argument to the callback:function readStreamAsString(stream , callback) { var data = "";stream.on("data", function(chunk) {data += chunk; });stream.on("end", function() { callback(null, data);});stream.on("error", function(error) {callback(error); });}Fixing a leakIt is enough to strip out all occurrences of two dots that have a slash, a backslash, or the end of the string on both sides. Using the replace method with a regular expression is the easiest way to do this. Do not forget the g flag on the expression, or replace will replace only a single instance, and people could still get around this safety measure by including additional double dots in their paths! Also make sure you do446
the replace after decoding the string, or it would be possible to foil the check by encoding a dot or a slash.Another potentially worrying case is when paths start with a slash, which are interpreted as absolute paths. But because urlToPath puts a dot character in front of the path, it is impossible to create requests that result in such a path. Multiple slashes in a row, inside the path, are odd but will be treated as a single slash by the file system.Creating directoriesYou can use the function that implements the DELETE method as a blueprint for the MKCOL method. When no file is found, try to create a directory with fs.mkdir. When a directory exists at that path, you can return a 204 response so that directory creation requests are idempotent. If a nondirectory file exists here, return an error code. The code 400 (“bad request”) would be appropriate here.A public space on the webYou can create a <textarea> element to hold the content of the file that is being edited. A GET request, using XMLHttpRequest, can be used to get the current content of the file. You can use relative URLs like index.html, instead of http://localhost:8000/index.html, to refer to files on the same server as the running script.Then, when the user clicks a button (you can use a <form> element and "submit" event or simply a "click" handler), make a PUT request to the same URL, with the content of the <textarea> as request body, to save the file.You can then add a <select> element that contains all the files in the server’s root directory by adding <option> elements containing the lines returned by a GET request to the URL /. When the user selects another file (a "change" event on the field), the script must fetch and display that file. Also make sure that when saving a file, you use the currently selected filename.Unfortunately, the server is too simplistic to be able to reliably read files from subdirectories since it does not tell us whether the thing we447
fetched with a GET request is a regular file or a directory. Can you think of a way to extend the server to address this?Project: Skill-Sharing Website Disk persistenceThe simplest solution I can come up with is to encode the whole talks object as JSON and dump it to a file with fs.writeFile. There is already a function (registerChange) that is called every time the server’s data changes. It can be extended to write the new data to disk.Pick a filename, for example ./talks.json. When the server starts, it can try to read that file with fs.readFile, and if that succeeds, the server can use the file’s contents as its starting data.Beware, though. The talks object started as a prototype-less object so that the in operator could be sanely used. JSON.parse will return regular objects with Object.prototype as their prototype. If you use JSON as your file format, you’ll have to copy the properties of the object returned by JSON.parse into a new, prototype-less object.Comment field resetsThe ad hoc approach is to simply store the state of a talk’s comment field (its content and whether it is focused) before redrawing the talk and then reset the field to its old state afterward.Another solution would be to not simply replace the old DOM structure with the new one but recursively compare them, node by node, and update only the parts that actually changed. This is a lot harder to implement, but it’s more general and continues working even if we add another text field.Better templatesYou could change instantiateTemplate so that its inner function takes not just a node but also a current context as an argument. You can then, when looping over a node’s child nodes, check whether the child has a template-repeat attribute. If it does, don’t instantiate it once but instead448
loop over the array indicated by the attribute’s value and instantiate it once for every element in the array, passing the current array element as context.Conditionals can be implemented in a similar way, with attributes called, for example, template-when and template-unless, which cause a node to be instantiated only when a given property is true (or false).The unscriptablesTwo central aspects of the approach taken in this chapter—a clean HTTP interface and client-side template rendering—don’t work with- out JavaScript. Normal HTML forms can send GET and POST requests but not PUT or DELETE requests and can send their data only to a fixed URL.Thus, the server would have to be revised to accept comments, new talks, and deleted talks through POST requests, whose bodies aren’t JSON but rather use the URL-encoded format that HTML forms use (see Chap- ter 17). These requests would have to return the full new page so that users see the new state of the site after they make a change. This would not be too hard to engineer and could be implemented alongside the “clean” HTTP interface.The code for rendering talks would have to be duplicated on the server. The index.html file, rather than being a static file, would have to be generated dynamically by adding a handler for it to the router. That way, it already includes the current talks and comments when it gets served.449
Index* operator, 14, 20, 167*= operator, 36+ operator, 14, 16, 20, 97, 167 ++ operator, 37+= operator, 36- operator, 14, 16, 20– operator, 37-= operator, 36/ operator, 14/= operator, 36<= operator, 17= operator, 25, 66, 182, 184, 213 == operator, 17, 20, 69, 85 === operator, 21, 85, 428?: operator, 19, 22[] (array), 62[] (subscript), 63% operator, 14, 36, 310, 424, 425,437, 439&& operator, 18, 21, 104|| operator, 18, 21, 54, 104, 132, 355, 424> operator, 17>= operator, 17< operator, 17{} (block), 33, 46, 91 {} (object), 65, 122200 (HTTP status code), 325, 385 204 (HTTP status code), 391, 392 2d (canvas context), 298400 (HTTP status code), 447404 (HTTP status code), 325, 390,407, 410405 (HTTP status code), 389 406 (HTTP status code), 441 500 (HTTP status code), 390, 395a (HTML tag), 224, 240, 242, 345 Abelson, Hal, 205absolute path, 447absolute positioning, 246, 251, 259,263, 271abstract syntax tree, see syntaxtreeabstraction, 6, 42, 86, 87, 90, 97,98, 101, 130, 205, 221, 232,332, 338 acceleration, 290Accept header, 340, 395, 441access control, 138, 163, 191, 404 Access-Control-Allow-Origin header,332actionTypes object, 141activeElement property, 344 actor, 276, 282, 287, 288, 316450
actorAt method, 287addEntry function, 69 addEventListener method, 253, 292,436 Apple, 227application (of functions), see func- tion applicationapply method, 92, 107 approximation, 128arc, 304–306arc method, 305, 440 arcTo method, 304, 305 area, 371argument, 27, 49, 54, 176, 206 arguments object, 79, 91, 426indexing, 80argv property, 379arithmetic, 14, 20, 213 Armstrong, Joe, 105array, 64, 65, 67, 73, 84, 88, 89,92, 93, 103, 128, 129, 162,168, 218, 276, 429as grid, 129, 374as table, 71creation, 62, 98, 130, 426 filtering, 94indexing, 63, 73, 77, 88, 117,130, 132, 411, 426, 437 length of, 64, 130methods, 76, 79, 84, 89, 94,95, 104, 411 searching, 73, 77 traversal, 88Array constructor, 130Array prototype, 108, 111 array-like object, 79, 92, 201, 214,232, 233, 245, 345, 349,352, 383 arrow function, 135artificial intelligence, 128, 140, 147,386 addition, 14, 126address, 324address bar, 222, 324, 326 adoption, 164age difference (exercise), 103, 428 alert function, 27, 49, 225 algorithm, 445alignment, 122all function, 341, 442alpha, 374alphanumeric character, 166alt attribute, 236alt key, 258altKey property, 258ambiguity, 219AMD, 197, 200American English, 167 ampersand character, 224, 327 analysis, 149, 153ancestor element, 283ancestry example, 92, 94–96, 99,101, 103 ANCESTRY_FILE data set, 93 angle, 248, 305, 306, 372, 440 angular brackets, 223, 224 animate method, 288animation, 139, 146, 246–248, 251,262, 270, 274, 276, 278, 285, 286, 288, 290, 291, 293, 294, 309, 310, 315, 318, 320, 323, 439, 440anonymous function, 192 appendChild method, 235, 280,451
217, 430artificial life, 128, 273, 357artificial stupidity (exercise), 147, 430ASCII art, 381assert function, 161assertion, 161, 162assignment, 25, 36, 182, 184, 219,436 assumption, 159, 162asterisk, 14, 167asynchronous I/O, 197, 330, 376,377asynchronous programming, 198–200, 295, 330, 333, 335, 337, 345, 352, 376–378, 382, 386, 390attack, 332attribute, 224, 238, 361, 443 authorization, 404autocompletion (exercise), 357, 443 autofocus attribute, 344automatic semicolon insertion, 24 avatar, 273average function, 97, 103, 428,429axis, 289, 299, 311, 312Babbage, Charles, 61 background, 273, 281, 286, 287,316background (CSS), 271, 273, 282 backgroundReadFile function, 198,332backslash character, 15, 164, 166,179, 224, 396, 433, 446 backtracking, 174, 178452backward compatibility, 190 ball, 323, 440Banks, Ian, 272bean counting (exercise), 60, 426 beforeunload event, 265 behavior, 131, 140, 186, 217, 430,431 benchmark, 241Berners-Lee, Tim, 324best practices, 3bezierCurve method, 303binary data, 4, 11, 383binary number, 11, 12, 72, 153,174, 350binary operator, 14, 16, 23bind method, 102, 107, 135 bit, 4, 11, 12, 17, 72 bitmap graphics, 308, 323 Blob type, 353block, 33, 34, 42, 157, 158, 206 block comment, 39, 178block element, 240, 242, 243 blocking, 197, 247, 266, 268, 330,377, 384 blur event, 264, 265blur method, 344body (HTML tag), 223, 225, 230 body (HTTP), 326, 327, 329, 385,391, 392, 408body property, 230, 231, 234bold, 242book analogy, 188, 204Book of Programming, 11, 376 Boolean, 17, 30, 33, 68, 165, 212,213conversion to, 21, 30, 34Boolean function, 30
border (CSS), 240, 243 border-radius (CSS), 259 bouncing, 131, 275, 277, 286, 289,323 BouncingCritter type, 131boundary, 171, 173, 179, 184, 186, 316, 432box, 163, 229, 273, 323, 440 box shadow (CSS), 283br (HTML tag), 443braces, see curly braces branching, 172, 174 branching recursion, 53, 313 break keyword, 36, 37 breakpoint, 154British English, 167browser, 2, 7, 27–29, 82, 193, 197,220, 222, 225–227, 253, 273, 274, 323, 324, 326, 328, 330, 332, 338, 339, 346, 354, 356, 365, 368, 396, 400, 401, 423browser wars, 227Browserify, 197browsers, 9brush, 360, 365, 366, 370 bubbling, see event propagation bucket fill, 374, 445budget, 423Buffer type, 383, 386, 387bug, 86, 149, 153, 179, 181, 186,189, 190, 227, 396 business software, 328button, 252, 326, 345, 358, 370 button (HTML tag), 226, 253, 258,cache, 196, 198, 434call method, 107, 112, 123, 136,142, 214call stack, 48–50, 54, 156, 157,159, 160callback function, 252, 293, 294,330, 332–335, 376, 377, 382,383, 386, 393, 416, 446 calling (of functions), see func-tion application camel case, 38, 244cancelAnimationFrame function, 267canvas, 274, 297, 300–305, 307– 314, 319–322, 362, 367, 368,373, 441context, 298, 299, 369 path, 301size, 298, 300canvas (HTML tag), 298, 360 canvas property, 362 CanvasDisplay type, 314–316, 318 capitalization, 38, 110, 168, 244,250, 328, 329, 387, 437 capture group, 169, 171, 176, 177,406 career, 272caret character, 166, 171, 184 carnivore, 148carriage return, 183 cascading, 244Cascading Style Sheets, see CSS case conversion, 64case keyword, 37 case-sensitivity, 168, 329, 433 casual computing, 1cat’s hat (exercise), 251271, 346, 354, 357 byName object, 99, 103453
catch keyword, 156, 157, 159, 160, 163, 432catch method, 337 CD, 11celery, 399cell, 357censored keyboard (exercise), 270, 437center, 284centering, 247century, 103, 429certificate, 339chaining, 336, 394change event, 344, 348, 356, 360,366, 369, 443, 447 chapter, 188character, 15, 258, 347 character category, 185 character encoding, 383 charAt method, 60, 79 charCode property, 258, 437 charCodeAt method, 257 chat, 221checkbox, 342, 348, 358, 443 checked attribute, 342, 348chess board (exercise), 41, 425 child node, 231, 233, 234, 261 childNodes property, 233, 236, 438 choice, 172Chrome, 227circle, 248, 304, 305, 372circle (SVG tag), 298circular dependency, 204, 434 circus, 76class attribute, 235, 240, 244, 280,282, 283, 362, 417 className property, 240cleaning up, 157, 285clearing, 239, 297, 309, 316, 441 clearInterval function, 267 clearRect method, 309, 441 clearTimeout function, 267, 268 cleverness, 201click event, 253, 255, 259, 442,443, 447client, 221, 338, 385, 400, 413 clientHeight property, 240 clientWidth property, 240 clientX property, 260, 363 clientY property, 260, 363 clipboard, 226, 270clipping, 316cloneNode method, 418cloning, 418closePath method, 302closing tag, 224, 225closure, 50, 91, 218, 352, 435, 436,438, 439 code, 8, 177, 272structure of, 23, 44 code golf, 186code structure, 34, 42, 124, 188 coin, 273–275, 287, 289–292, 319 Coin type, 278, 289 collaboration, 220collection, 6, 62, 65, 67, 84, 126, 430collision detection, 286, 287, 289– 291, 440colon character, 19, 37, 66, 243 color, 298, 300, 316, 360, 365, 373 color (CSS), 243color picker, 365color picker (exercise), 373, 444454
colWidths function, 116comma character, 206command key, 258command line, 376, 378–380 comment, 39, 93, 177, 182, 184,218, 231, 400, 403, 409,419, 435comment field reset (exercise), 422,444, 446 concurrency, 266conditional execution, 19, 30, 37, 41, 212, 422conditional operator, 19, 22 configuration, 182confirm function, 29 Confucius, 2connection, 221, 324, 330, 333, 339, 400, 401consistency, 38, 220, 232 console.log, 6, 10, 16, 28, 48, 50,58, 80, 154, 379, 388 constant, 81, 290constructor, 38, 109, 110, 121– 124, 126, 131, 132, 134, 141, 151, 157, 170, 179,275content negotiation (exercise), 340,395, 441, 446 Content-Length header, 325Content-Type header, 325, 385, 389, 397context, 299, 362, 363, 369 context menu, 256context parameter, 135, 136 continue keyword, 36control flow, 30, 32, 34, 35, 48,91, 156, 252, 337, 378 control key, 258control point, 302–304controls object, 361, 365 convention, 38, 201Conway’s Game of Life, 357 coordinates, 126, 129, 130, 133,248, 259, 260, 276, 281, 284, 287, 299, 300, 305,448COMMENT_NODE code, 231 CommonJS, 194, 195, 197, 204,380, 381 communication, 220, 338community, 377comparison, 17, 21, 33, 37, 85,213, 426 of colors, 445of DOM nodes, 448 of NaN, 18of numbers, 17, 28 of objects, 69of strings, 17of undefined values, 20 compass direction, 131, 140 compatibility, 7, 220, 227, 328,365 compilation, 216, 435completion, 328, 357complexity, 3, 4, 86, 98, 105, 124,175, 202, 245, 266, 279 composability, 6, 97, 98, 201compositing, 365 composition, 124 computed property, 63 computer, 1, 3concat method, 77, 103, 120, 436 concatenation, 16, 77, 120, 436,455
311, 363, 444, 445 copy-paste programming, 56, 189 copying, 418correlation, 70, 71, 73, 75, 76 cosine, 81, 248counter variable, 32, 35, 248, 425,426, 437, 442 CPU, 377crash, 159, 162, 393, 408, 422 createElement method, 237, 360,436createPaint function, 361createReadStream function, 387, 390createServer function, 384, 386, 405, 406createTextNode method, 236, 442 createWriteStream function, 386,392 crisp, 320critter, 128, 131, 136, 140, 143, 145, 148Crockford, Douglas, 220 cross-domain request, 332, 368,373 crying, 168cryptography, 339CSS, 243, 244, 262, 281–283, 285,297, 300, 362 ctrlKey property, 258curl program, 392curly braces, 33, 42, 65, 66, 89,168, 425 cursor, 347, 348curve, 302–304 cycle, 231Dark Blue (game), 272dash character, 14, 166, 244 data, 3, 11, 61data attribute, 238, 239, 271 data event, 387data format, 92, 232, 331data loss, 422data set, 72, 92, 119data structure, 61, 62, 74, 84, 99,129, 201, 206, 231, 320,358, 431 data URL, 367database, 328dataTable function, 120, 123 date, 166, 168–170Date constructor, 170date field, 365Date type, 191, 203Date.now function, 170, 403 dblclick event, 259debouncing, 268debugger statement, 154 debugging, 7, 149–151, 153, 154,157, 160–162, 186 decentralization, 220decimal number, 11, 153, 174 declaration, 243 decodeURIComponent function,327, 389, 406, 446 decoupling, 190deep comparison, 69, 85deep comparison (exercise), 85,428default behavior, 242, 256, 437 default keyword, 37default value, 21, 100, 300, 355,426456
defensive programming, 137, 139 define function, 198–200 defineProperty function, 113, 122,429 degree, 305, 311DELETE method, 325, 326, 388, 391, 408, 419delete operator, 67denodeify function, 393 dependence, 70dependency, 189, 190, 194, 197,199, 204, 382 deserialization, 93developer tools, 9, 28, 154, 159 dialog box, 27, 29diamond, 322, 439digit, 11, 13, 153, 166–169, 187 Dijkstra, Edsger, 128 dimensions, 126, 128, 240, 272,274, 286, 298, 425 dinosaur, 217direct child node, 245directions object, 131, 140 directory, 382, 384, 388–391, 396,397, 447 disabled attribute, 345discretization, 128, 273, 286, 288, 293dispatching, 37, 405display, 280, 294, 314, 320, 321,415, 416display (CSS), 243, 271, 414division, 14 division by zero, 15 DNA, 99–101do loop, 34 doctype, 223, 225document, 222, 229, 265, 297 document format, 338, 340 Document Object Model, see DOM documentation, 201, 376 documentElement property, 230,330dollar sign, 25, 171, 176, 184DOM, 230–232, 234, 235, 238, 245, 253, 258, 273, 274, 280, 282, 283, 297, 298, 320, 331, 342, 347, 360, 414,418construction, 232, 235, 237,360, 415domain, 222, 325, 332, 354, 368 domain-specific language, 86, 152,164, 217, 245, 337, 415 DOMDisplay type, 280, 281, 314 dot character, see period charac-ter double click, 259double-quote character, 15, 187, 205, 224download, 8, 190, 250, 392, 400, 421draggable bar example, 260 dragging, 260drawImage method, 308, 309, 311,314, 317, 318, 441 drawing, 229, 240, 241, 247, 280,283, 298–300, 302, 313, 318,319, 359, 360, 365, 443 drawing program example, 259,359drawTable function, 117drawTalk function, 417, 418, 423 drop-down menu, 343, 350457
duplication, 190, 434 dynamic scope, 157 dynamic typing, 149ECMAScript, 7, 8ECMAScript 6, 8, 46, 135, 335 ecosystem, 128, 147, 148ecstatic module, 406editor, 274efficiency, 52, 84, 98, 196, 216,241, 274, 282, 299, 430 Egg language, 205, 206, 209–211,213–215, 217, 218, 231 electronic life, 128, 131, 132, 134, 136, 137, 139, 141, 142,144, 145, 203, 273 elegance, 52, 98, 207element, 224, 231, 237 ELEMENT_NODE code, 231, 436 elementFromChar function, 133 elements property, 345, 346 ellipse, 247, 248else keyword, 31elt function, 237, 361, 414email, 338email field, 365empty set, 178encapsulation, 105, 106, 124, 129,130, 189–191, 201, 204, 253,279 encodeURIComponent function,327, 402 encoding, 221encryption, 339end event, 387end method, 385, 386, 389, 446 enemies example, 182458energy, 141–144, 430 engineering, 227ENOENT (status code), 390, 395 Enter key, 346enter key, 369entity, 224entropy, 141enumerability, 113environment, 27, 211, 213, 214,266, 435 equality, 17erase tool, 364, 365error, 149–151, 153–155, 159, 160 error event, 334, 353, 392error handling, 149, 155, 156, 159,333, 336, 337, 382, 390,393, 394, 416, 421 error message, 210, 337, 357error recovery, 154error response, 325, 333, 390, 391,393error tolerance, 137, 224Error type, 157, 159, 160, 390 escape key, 296escapingin HTML, 224, 226in regexps, 164, 166, 179in strings, 15, 205in URLs, 327, 389, 402, 406Escher, M.C., 297eval, 194evaluate function, 210, 211, 213 evaluation, 194, 210, 215, 216 even number, 32, 59event handling, 199, 252–254, 256,257, 262, 264, 266, 273, 292, 295, 296, 308, 320,
330, 346, 347, 349, 360,386, 419, 438, 439, 443 event object, 254, 257, 259, 260,363, 372event propagation, 254, 255, 261,264, 265 event type, 254every and some (exercise), 104, 429every method, 104evolution, 164, 189exception, 334, 393exception handling, 156, 157, 159–161, 163, 333, 334, 368,393, 394, 442, 444exec method, 168, 169, 180, 181 execution order, 30, 47, 48 exercises, 2, 8, 40, 153exit method, 379expectation, 256experiment, 3, 8, 186, 258 exploit, 226exponent, 13, 187, 433 exponentiation, 33, 35exporting, 193, 196, 434exports object, 193, 195, 196, 381,434expression, 23, 24, 28, 33, 35, 46,192, 205, 206, 211 expressivity, 1, 217extinction, 147 extraction, 169factorial function, 10 failure, 333 fallthrough, 37false, 17farm example, 56, 58, 172 farmer, 92field, 259, 326, 342, 345, 349, 353,358, 360, 365, 422, 448 figlet module, 381file, 188, 194, 325, 326, 351, 359, 369, 380, 383, 384, 386,388–391, 448 file extension, 389file field, 342, 351, 352 file format, 182file reading, 352file server, 413file server example, 388, 389, 391, 392, 394, 396, 397, 446,447file system, 351, 360, 368, 382,383, 388, 448 File type, 352FileReader type, 352, 353, 369 files property, 352fill method, 301fillColor property, 307filling, 300, 301, 307, 321 fillRect method, 300, 309, 372,375, 444fillStyle property, 300, 360, 362,366fillText method, 307, 308, 440 filter method, 94, 102, 117, 276,428finally keyword, 158, 163, 432 finish event, 392Firefox, 227, 328firewall, 397, 401firstChild property, 233fixed positioning, 263459
FizzBuzz (exercise), 41, 424 flattening (exercise), 103 flexibility, 7flipHorizontally function, 318, 439 flipHorizontally method, 312 flipping, see mirroring floating-point number, 13flood fill (exercise), 374, 445 flow diagram, 172, 174focus, 258, 264, 344, 345, 348,349, 422, 448 focus event, 264, 265, 368focus method, 344fold function, 95font, 308, 370font-family (CSS), 244 font-weight (CSS), 244food, 141, 143, 145, 147, 431 food chain, 145, 148for attribute, 349for loop, 35, 36, 74, 88, 133, 160,426, 427for/in loop, 74, 75, 112–114, 121,428, 429forEach method, 88, 89, 92, 98,117, 134, 352, 438form, 326, 327, 342, 345, 346, 397 form (HTML tag), 342, 345, 369, 414, 420, 447, 449form property, 345forwarding, 404fractal example, 313fractional number, 13, 187, 273 frame, 309, 310, 315, 318, 441 framework, 57, 144 fromCharCode function, 258fs module, 382–384, 396460fsp object, 394function, 6, 27, 42, 150, 188, 205,206, 215, 438application, 27, 28, 43, 48, 49,52, 92, 94, 98, 102, 159,211as namespace, 189, 191as property, 64as value, 42, 46, 50, 88, 90,94, 97, 98, 102, 142, 254,293, 295, 332, 439 body, 42declaration, 47definition, 42, 47, 55 higher-order, 47, 88–90, 92,94, 95, 97, 100, 116, 135,136, 177, 293, 295 model of, 51naming, 55, 57purity, 58scope, 43, 45, 134, 218 wrapping, 91Function constructor, 195, 199, 213, 216, 357, 442function keyword, 42, 47, 192 Function prototype, 108, 111 future, 8, 26, 47, 135, 185, 200,323, 335game, 257, 272, 273, 275, 292, 295, 314screenshot, 285, 319game of life (exercise), 357, 443 GAME_LEVELS data set, 295 garbage collection, 12garble example, 380gardening, 399
gatherCorrelations function, 74 gaudy home pages, 270 generation, 357, 358, 443get function, 335GET method, 325, 326, 329, 346, 386, 388, 389, 402, 407,447getAttribute method, 238, 240 getBoundingClientRect method,241, 260, 363 getContext method, 299getDate method, 171getDay method, 191 getElementById method, 234 getElementsByClassName method,235getElementsByName method, 349 getElementsByTagName method,234, 236, 239, 250, 436 getFullYear method, 171getHours method, 171 getImageData method, 373, 374 getItem method, 354, 355 getMinutes method, 171 getMonth method, 171 getPrototypeOf function, 108–110,219, 436 getResponseHeader method, 329 getSeconds method, 171getter, 121, 122, 126getTime method, 170getURL function, 334getYear method, 171global object, 82, 134, 150, 379 global scope, 44, 82, 189, 191,192, 197, 213, 253, 267, 379, 380, 436461globalCompositeOperation prop- erty, 365Goethe, Johann Wolfgang von, 342 Google, 227graceful degradation, 423 grammar, 23, 182grandfather, 99, 100graph, 321graphical user interface, 1 graphics, 273, 274, 279, 282, 297–299, 308, 320, 321 gravity, 290greater than, 17greed, 177, 178grid, 128–130, 136, 139, 273, 274,276, 281, 287, 357, 374,443 Grid type, 130groupBy function, 103grouping, 14, 33, 103, 168, 169,176, 177, 429, 432h1 (HTML tag), 223, 240hard drive, 11, 351, 354, 376, 422 hard-coding, 234, 322, 362 hasEvent function, 72hash character, 218 hasOwnProperty method, 113, 114,219, 436head (HTML tag), 223, 225, 230 head property, 230header, 325, 326, 329, 332, 385 height (CSS), 372help text example, 264helper function, 232herbivore, 145, 147, 148, 431 hexadecimal number, 174, 327
hidden element, 243, 271, 414 higher-order function, see func-tion, higher-order highlightCode function, 239history, 7, 105, 412holy war, 105hooligan, 404Host header, 325, 329hover effect, 261, 262href attribute, 224, 234, 238, 367 HTML, 223, 225, 229, 231, 249,297–299, 320, 321, 324, 353,360, 397html (HTML tag), 225, 230HTML5 form fields, 365 HTTP, 222, 324–328, 331, 334, 335, 338, 339, 384, 385, 388, 391,397, 400–402http module, 384, 385, 396 HTTPS, 222, 338, 339, 386332, 342, 392,imagination, 272img (HTML tag), 224, 236, 242,265, 297, 308, 309, 368 implementation, 185implementation detail, 190 implements (reserved word), 26 in operator, 67, 73, 112–114, 428 indentation, 34, 35index, 63, 117index property, 169index.html, 413indexOf method, 73, 77, 78, 165,180, 411, 443infinite loop, 36, 49, 141, 160, 426 infinity, 15inheritance, 108, 122–125, 141, 160,390ini file, 182, 189initialization, 265, 414, 415 inline element, 240, 242inner function, 45, 91, 118, 436 inner loop, 98, 175innerHeight property, 263 innerWidth property, 263input, 29, 137, 149, 154, 252, 274,344, 376, 408input (HTML tag), 264, 270, 342,347–349, 351 input event, 348, 443insertBefore method, 235 install, 381installation, 190 instance, 110instanceof operator, 124, 160 instantiateTemplate function, 423,448 instantiation, 417462https module, 386human language, 1, 23, 42hype, 106Hypertext Markup Language, seeHTMLHypertext Transfer Prototol, seeHTTPid attribute, 234, 244, 349, 414 idempotency, 391, 447 identifier, 206identitiy, 69if keyword, 30, 184chaining, 31, 37, 424, 425image, 224, 236, 265, 297, 326, 360, 368
instruction, 4integer, 13integration, 164, 232 interconnection, 188interface, 105, 115, 116, 118, 123,126, 131, 138, 164, 190– 192, 194, 198, 232, 279, 297, 299, 314, 328, 335, 336, 347, 402, 430design, 57, 164, 170, 176, 180, 191, 200, 232, 301, 328interface (reserved word), 26 interface design, 202 internationalization, 184 Internet, 182, 220–222, 226, 396,397Internet Explorer, 227, 328interpretation, 8, 194, 210, 211, 215, 216interview question, 41inversion, 166invoking (of functions), see func-tion applicationIP address, 222, 324, 326, 397 isEven (exercise), 59, 425 isInside function, 261isNaN function, 31isolation, 105, 189, 190, 192, 194,226 iteration, 126Jacques, 61 Java, 7 JavaScript, 7absence of, 423 availability of, 1 flexibility of, 7history of, 7, 220 in HTML, 225 syntax, 23uses of, 8 versions of, 8 weaknesses of, 7JavaScript console, 9, 16, 28, 154, 159, 357, 379JavaScript Object Notation, see JSONjob, 76, 306join method, 65, 112, 118, 214,381journal, 62, 65, 68, 69, 74, 80 JOURNAL data set, 72JSON, 92, 93, 331, 336, 337, 354,355, 382, 402, 407, 408,448JSON.parse function, 93, 448 JSON.stringify function, 93 jump, 5jump-and-run game, 272 jumping, 273, 290Kernighan, Brian, 149key code, 257, 258, 292 keyboard, 27, 256, 257, 273, 288,290, 292, 296, 344, 345,347keyboard focus, see focuskeyCode property, 257, 437 keydown event, 257, 258, 268, 293,437keypress event, 258, 437keyup event, 257, 258, 293 keyword, 24, 26, 238 Khasekhemwy, 347463
kill, 385Knuth, Donald, 42 Kurds, 270label, 308, 323label (HTML tag), 349labeling, 349landscape example, 45 Last-Modified header, 325 lastChild property, 233 lastIndex property, 180, 181 lastIndexOf method, 77lava, 273–275, 277, 283, 286–290,292, 319 Lava type, 277, 288layering, 202, 221 layout, 240, 241, 243 laziness, 241leaf node, 231leak, 226, 296, 368, 396, 446 learning, 2, 3, 8, 399left (CSS), 246–248, 251, 372 legend, 132length property, 79for arrays, 64, 88for strings, 56, 63, 79, 426less than, 17let keyword, 26, 46level, 273–276, 280, 283, 288, 294,295, 438 Level type, 275lexical scoping, 45, 46, 91library, 190, 232, 333, 380–382 life expectancy (exercise), 103, 429 LifeLikeWorld type, 141line, 24, 34, 183, 184, 297, 300–303, 305, 306, 322, 364,464439line break, 15, 183line comment, 39, 178line tool, 360, 363, 364line width, 300, 310lineCap property, 364lines of code, 215lineTo method, 301, 305 lineWidth property, 300, 360, 362,364, 367link, 224, 233, 234, 256, 258, 360 link (HTML tag), 285linked list, 84, 427list (exercise), 84, 427listen method, 384, 385listening (TCP), 221, 384literal expression, 23, 164, 208,211literate programming, 189live data structure, 229, 236, 246, 438live view, 400, 401, 416lives (exercise), 295, 438load event, 265, 308, 318, 330,352, 368, 441 loading, 197local scope, 189, 215local variable, 43, 50, 89, 91, 219,426, 438 localhost, 384localStorage object, 354, 355, 420 locked box (exercise), 163, 432 logging, 154logical and, 18logical operators, 18logical or, 18long polling, 401–403, 408, 410,
411, 415, 420, 421 long-polling, 401loop, 5, 6, 32, 35, 40, 41, 52, 88, 89, 96–98, 135, 181, 422,425, 426, 438, 439 termination of, 36loop body, 34, 89 lycanthropy, 61, 69machine code, 4, 216mafia, 227, 332magic, 100, 108, 205, 368 malicious script, 226, 265 man-in-the-middle, 338map, 74, 99, 103, 112–114, 277,346, 429map method, 95, 116–118, 135,381, 428 Marcus Aurelius, 252match method, 169, 181 matching, 165, 171, 172, 180, 186algorithm, 172–175Math object, 59, 63, 80 Math.abs function, 444 Math.acos function, 81 Math.asin function, 81 Math.atan function, 81 Math.ceil function, 82, 287, 317 Math.cos function, 81, 248, 372,440Math.floor function, 82, 287, 317 Math.max function, 28, 63, 80,316Math.min function, 28, 59, 80,316, 444Math.PI constant, 81, 305Math.random function, 81, 132,465145, 278, 357 Math.round function, 82Math.sin function, 81, 248, 278, 289, 372Math.sqrt function, 72, 80, 429 Math.tan function, 81 mathematics, 52, 90 max-height (CSS), 283 max-width (CSS), 283 maximum, 28, 80, 116media type, 338, 340, 389 medicine, 95meetup, 399memory, 4, 11, 24, 48, 62, 69, 84,216, 353, 422 mental model, 201Mephistopheles, 342mesh, 222message, 266message box, 27message event, 267meta key, 258metaKey property, 258method, 64, 76, 92, 105, 107, 108,121, 124, 131, 150, 325,338, 385, 392, 402, 405 method attribute, 326method call, 102, 107 methods object, 388 Microsoft, 227, 328 Microsoft Paint, 359mime module, 389MIME type, 340, 389, 396 mini application, 353 minimalism, 189, 272 minimum, 28, 59, 80, 96 minimum (exercise), 59, 425
minus, 14, 187Miro, Joan, 359mirror, 312, 323, 441mirroring, 310, 311MKCOL method, 397, 447 mkdir function, 447 modification date, 391modifier key, 258modularity, 328module, 188–191, 193, 194, 196,197, 203, 280, 376, 380,381, 405module loader, 194, 197, 200, 380 module object, 196modulo operator, 14Mongolian vowel separator, 184 month name (exercise), 203, 433 Mosaic, 227motion, 273MOUNTAINS data set, 115, 119,250mouse, 27, 360, 362, 363, 372,443mouse button, 254, 255, 259mouse cursor, 259mouse trail (exercise), 270, 437 mousedown event, 255, 259, 360,363, 442mousemove event, 260, 261, 268,269, 271, 360, 363, 364,437 mouseout event, 261mouseover event, 261, 368 mouseup event, 259, 261, 360, 363 moveTo method, 301, 305 Mozilla, 227, 328multiple attribute, 350, 352466multiple choice, 343 multiple-choice, 342, 349 multiplication, 14, 277, 289 multiplier function, 51 music, 272mutability, 66, 68, 112 mutation, 430name attribute, 346, 349 namespace, 80, 189, 191, 194, 195 namespace pollution, 80, 189, 192 naming, 5, 7NaN, 15, 18, 19, 150negation, 16, 18neighbor, 357, 443nerd, 179nestingin regexps, 175of arrays, 71of expressions, 23, 207of functions, 45, 91, 118 of loops, 41, 98, 133, 425 of objects, 230, 233of scope, 45Netscape, 7, 227network, 220–222, 295, 338, 376,377, 403 new operator, 109newline character, 15, 41, 166, 178, 183, 442nextSibling property, 233node, 230, 231node program, 378, 379Node.js, 8, 9, 28, 190, 197, 376–378, 380–382, 384–386, 388, 389, 391–393, 395, 400, 402, 404, 421
node_modules directory, 380, 382 NodeList type, 232nodeType property, 231, 436, 438 nodeValue property, 234 nonbreaking space, 184not a number, 15note-taking example, 354 notification, 401NPM, 190, 380–382, 389, 393, 405,406npm program, 381, 382, 389null, 19, 20, 54, 63, 85, 92, 102, 132, 155, 428number, 12, 68, 165, 187, 433 conversion to, 20, 30 notation, 12, 13precision of, 13 representation, 12special values, 15 number field, 365Number function, 30, 38 number puzzle example, 53object, 28, 61, 65, 67, 68, 73, 80, 82, 84, 93, 105, 108, 124,129, 230, 428as map, 73, 99, 103, 112–114,131, 133, 277, 429 creation, 109identity, 69 looping over, 74 property, 63Object prototype, 108, 109, 113, 114object-oriented programming, 105, 106, 115, 124Object.create function, 109, 114,215Object.keys function, 121, 132, 250 obstacle, 141, 286obstacleAt method, 286 offsetHeight property, 240, 241 offsetWidth property, 240on method, 386onclick attribute, 226, 253open method, 328–330OpenGL, 298opening tag, 224operator, 14, 16, 17, 21, 206, 213application, 14optimization, 52, 58, 98, 241, 268,274, 282, 320, 323, 355,367, 375, 384option (HTML tag), 343, 344, 349,350, 363, 447 optional, 167optional argument, 49, 79, 83 options property, 350 ordering, 221organization, 188, 189 outline, 300output, 16, 27, 28, 149, 154, 214, 376, 396, 442overflow, 13overflow (CSS), 283overlap, 287overlay, 244overriding, 110, 115, 123, 434 overwriting, 392, 397, 408p (HTML tag), 223, 240 package (reserved word), 26 package manager, 190 package.json file, 382467
padding (CSS), 281page reload, 265, 342, 346, 354,449pageX property, 259, 372pageXOffset property, 241 pageY property, 259, 372 pageYOffset property, 241, 263 Palef, Thomas, 272paragraph, 224parallelism, 266, 326, 377, 378 parameter, 27, 42, 43, 49, 79, 89,91, 92, 151, 438 parent node, 254parentheses, 14, 23, 27, 31, 33, 35, 89, 168, 171, 172, 184,192, 206, 432 parentNode property, 233parse function, 209parseApply function, 208 parseExpression function, 207 parseINI function, 184parsing, 93, 149, 184, 192, 205–207, 209, 211, 214, 224,229, 328, 389, 410 partial application, 102 password, 338, 396, 404password field, 342 pathcanvas, 301, 302, 305, 364, 439 closing, 301, 302file system, 380, 388, 389, 447 URL, 325, 329, 388, 389, 402,405pathfinding, 140, 147, 431patience, 374pattern, 164–166, 179 pausing (exercise), 296, 439pea soup, 87peanuts, 76percent, 263percent sign, 327performance, 175, 216, 241, 266,274, 320, 375, 384period character, 28, 63, 166, 178,187, 446persistence, 353, 400, 420, 422,448phase, 278, 279, 289phi coefficient, 70–72phi function, 72 photosynthesis, 141, 142, 145 physics, 285, 290, 437 physics engine, 286pi, 13, 81, 248, 278, 305PI constant, 81picture, 297, 298, 309, 320, 360 pie chart example, 306, 308, 323,440 pipe, 221pipe character, 172, 433pipe method, 389, 392pixel, 240, 249, 259, 274, 281, 297–299, 308, 309, 316, 320,321, 323, 368, 373, 374 pixel art, 309pizza, 70, 71placeholder, 415, 418plant, 141, 142, 144, 145, 147,431 Plant type, 144PlantEater type, 145platform game, 272, 295 Plaugher, P.J., 149player, 272–276, 283, 286, 287,468
289, 291, 294, 319 player character, 309, 318Player type, 277, 289plus character, 14, 167, 187plus function, 97Poignant Guide, 23pointer, 233polling, 252polymorphism, 115, 124pop method, 65, 76Popper, Karl, 237port, 221, 324, 384, 385pose, 309position, 241position (CSS), 246, 251, 263, 273,282, 283, 372, 444POST method, 326, 327, 346, 403,419, 449 postMessage method, 267power example, 43, 49, 52, 215 pre (HTML tag), 239 precedence, 14, 18, 244, 245 predators (exercise), 148, 431 predicate function, 94, 104 predictability, 201premature optimization, 53 preprocessing, 197 preventDefault method, 256, 264,265, 292, 346, 363, 437 previousSibling property, 233 primitiveMultiply (exercise), 163,432 privacy, 226, 368private (reserved word), 26 private property, 138, 163 process object, 379 profiling, 53, 98program, 23, 30 nature of, 3program size, 86, 186, 279, 337 programmingdifficulty of, 2 history of, 4 joy of, 3programming language, 1, 4, 149, 189, 205, 217, 232, 238,377 power of, 6programming style, 3, 24, 33–35, 38, 117, 121, 124, 279, 394progress bar, 263project chapter, 128, 188, 205, 272,359, 399promise, 335–337, 341, 353, 393–395, 442Promise constructor, 335, 341, 442 promise module, 393prompt function, 29, 370 promptDirection function, 159, 161 promptInteger function, 155 propagation, see event propaga-tionproperty, 28, 63, 65, 82, 107, 108,110, 113, 121, 133, 150,238, 300 assignment, 66 deletion, 67 model of, 66 naming, 138 own, 114 testing for, 67protected (reserved word), 26 protocol, 221, 222, 324, 325, 367 prototype, 108–112, 123, 192, 215,469
219, 435, 448 avoidance, 114 diagram, 111 interference, 112 pollution, 113, 114prototype property, 110proxy, 404pseudo array, see array-like ob-jectpseudo-random number, 81pseudoselector, 262public (reserved word), 26 public space (exercise), 397, 447 publishing, 382punch card, 4pure function, 57, 58, 84, 94, 98,201, 357, 430, 443 push method, 65, 76pushing data, 400PUT method, 325, 326, 388, 392,402, 408, 420, 447 Pythagoras, 371, 429quadratic curve, 303 quadraticCurveTo method, 302,440query string, 326, 327, 403, 410,449querySelector method, 246, 360,417querySelectorAll method, 245 question mark, 19, 167, 178, 327 quirks, 227quotation mark, 15, 187quotingin JSON, 93of object properties, 66quoting style (exercise), 187, 432rabbit example, 107, 109, 110, 112 radian, 305, 311radio button, 342, 349radius, 304, 372radix, 11raising (exception), 156random number, 81, 132, 145, 278,370randomElement function, 132 range, 166, 168range function, 6, 83, 426ray tracer, 321read-eval-print loop, 379 readability, 5, 6, 38, 52, 57, 88,98, 155, 188, 211, 284, 322,335, 337, 360readable stream, 386, 387, 389,446readAsDataURL method, 369 readAsText method, 352readdir function, 383, 391 readFile function, 194, 383, 393,448readFileSync function, 384reading code, 8, 128 readStreamAsJSON function, 408,409readStreamAsString function, 446 real-time, 252reasoning, 18recipe analogy, 87record, 65, 131recovery, 421rect (SVG tag), 298rectangle, 273, 286, 299, 300, 322470
rectangle tool (exercise), 372, 444 recursion, 49, 52, 53, 59, 85, 100, 207, 209, 211, 233, 250, 313, 418, 425, 427, 432,436, 448reduce method, 95, 96, 99, 103,116, 117reduceAncestors function, 100, 101 ReferenceError type, 219RegExp constructor, 164, 179 regexp golf (exercise), 186 registerChange function, 408, 412,removeChild method, 235 removeEventListener method, 253,439removeItem method, 354rename function, 383rendering, 299repeating key, 257repetition, 55, 167, 168, 175, 179,267, 422, 448replace method, 176, 187, 432,446replaceChild method, 235replaceSelection function, 348 reproduction, 141, 143–145, 147,431request, 324–326, 328, 346, 384–386, 392, 400request function, 385, 386, 396,446 requestAnimationFrame function,247, 266, 267, 293, 323,437require function, 194–197, 204, 380,382, 389, 405 RequireJS, 200reserved word, 26, 240reset, 448resize, 369resolution, 380resource, 222, 325, 326, 338, 367,388, 407response, 324–326, 332, 385, 389,391, 394, 446 responseText property, 329, 330 responseXML property, 330 responsiveness, 252, 376restore method, 313, 314448regular expression, 164–166, 176–180, 182, 185, 186, 208,239, 405, 406, 435, 446 alternatives, 172 backtracking, 174 boundary, 171creation, 164, 179 escaping, 164, 179, 433 flags, 168, 176, 179, 433 global, 176, 180, 181 grouping, 168, 176 internationalization, 184 matching, 172, 173, 180 methods, 165, 169, 180 repetition, 167relatedTarget property, 261 relative path, 380, 388, 396, 447 relative positioning, 246, 247 relative URL, 329relativePos function, 363, 444 remainder operator, 14, 36, 310,424, 425, 437, 439 remote access, 388remote procedure call, 338471
result property, 352return keyword, 43, 48, 109, 425,429return value, 28, 43, 155, 382,428reuse, 58, 190, 380 reverse method, 84reverse proxy, 404reversing (exercise), 84, 427rgb (CSS), 282, 373, 444 right-aligning, 121, 250 robustness, 401root, 231rotate method, 311, 314 rotation, 322, 439rounding, 82, 154, 287, 304, 317 router, 397, 401, 405Router type, 405, 406row, 250rowHeights function, 116 RTextCell type, 122rule (CSS), 244, 245run function, 214run-time error, 149, 151, 153, 154,162, 436runAnimation function, 293, 296 runGame function, 294, 295, 438 runLevel function, 294, 296 running code, 8Safari, 227sandbox, 8, 61, 93, 119, 226, 229,331, 368, 373 save link, 367save method, 313, 314 saving, 360scale method, 310, 312scaling, 281, 309, 310, 318, 441 scheduling, 376scientific notation, 13, 187 scope, 43–45, 50, 82, 134, 189,191, 195, 218, 219, 436 script (HTML tag), 225, 265, 266,415scroll event, 262, 268scrolling, 256, 262, 263, 284, 292, 316search method, 180searching, 173, 174, 180, 234, 374 section, 183, 184Secure HTTP, see HTTPS security, 226, 331, 338, 351, 354,368, 389, 396, 404 SecurityError type, 368, 444select (HTML tag), 343, 344, 349, 350, 354, 360, 362, 447selected attribute, 350 selection, 347, 363 selectionEnd property, 347 selectionStart property, 347 selector, 245self variable, 134, 135 self-closing tag, 224 semicolon, 23, 24, 35, 243 send method, 328–330 sequence, 167sequence (exercise), 126, 430 serialization, 93server, 221, 222, 324–326, 328,329, 332, 338, 376, 384,385, 387, 388, 400, 404 session, 356, 368sessionStorage object, 356 set, 165, 166, 231472
setAttribute method, 238, 240 setInterval function, 267, 309, 371 setItem method, 354, 355 setRequestHeader method, 329,340 setter, 121, 122setTimeout function, 267, 268, 411 shape, 297, 301, 304, 308, 322 shapes (exercise), 322, 439shared property, 109–111, 123 shift key, 258shift method, 76shiftKey property, 258 short-circuit evaluation, 22, 54,212, 429 SICP, 205side effect, 24, 28, 36, 43, 58, 68, 84, 94, 181, 192, 232, 235,241, 301, 313 sign, 13, 187, 433sign bit, 13signal, 11simplicity, 202, 216simulation, 128, 132, 136, 139,141, 146, 272, 277, 357,437sine, 81, 248, 278, 289single-quote character, 15, 187, 226size attribute, 350skill, 360skill-sharing, 399skill-sharing project, 399, 400, 402,404, 413, 423 skipSpace function, 208, 218slash character, 14, 39, 164, 178, 329, 396, 446, 447slice method, 77, 78, 236, 353, 435sloppy programming, 137, 269 smooth animation, 248 SMTP, 221some method, 104, 406 sorting, 231source property, 180 special form, 205, 211 special return value, 155 specialForms object, 211 specificity, 245speed, 323, 441spell-check example, 201spiral, 322, 439splice method, 411split method, 118, 381spray paint tool, 370sprite, 309, 317, 318spy, 262square, 30, 42square brackets, 63, 73, 166, 426 square example, 47square root, 72, 80, 429src attribute, 224, 225stability, 147, 148, 190, 431 stack, see call stack, 333stack overflow, 49, 52, 60, 425 stack trace, 157, 161, 393 standard, 7, 27, 38, 47, 94, 135,157, 184, 194, 197, 220,365, 377, 379 standard environment, 27 standard output, 379, 388standards, 227 star, 322, 440 Star Trek, 303473
starvation, 147, 431stat function, 383, 390, 395 state, 24, 33, 35, 36, 276, 300,313, 315, 422, 430, 438 statement, 23, 24, 30, 33, 35, 43,192static (reserved word), 26static file, 402, 406static typing, 149Stats type, 390status code, 325, 329, 333, 334,379, 389 status property, 329statusText property, 329 stdout property, 388stoicism, 252stopPropagation method, 255 stream, 221, 385–387, 389, 392 StretchCell (exercise), 126, 430 strict mode, 150string, 15, 62, 64, 65, 68, 257, 258 indexing, 60, 77, 79, 169 methods, 78, 118, 169 notation, 15properties, 78searching, 78String function, 30, 115stroke method, 301–303 strokeRect method, 300, 440 strokeStyle property, 300, 360, 364,366strokeText method, 307, 308stroking, 300, 307, 321strong (HTML tag), 239, 240, 242 structure, 189, 223, 229 structure sharing, 84style, 242474style (HTML tag), 244style attribute, 242–244, 280 style sheet, 244, 245, 280, 281,283, 285, 367, 413 submit, 342, 346submit event, 346, 347, 369, 414, 420, 447substitution, 58subtraction, 14, 126suggestion, 357sum function, 6, 83summing (exercise), 83, 426 summing example, 5, 86, 95, 214 survey, 306Sussman, Gerald, 205SVG, 297, 299, 300, 320, 321 switch keyword, 37 synchronization, 403, 416, 420 synchronous I/O, 197, 330, 376,377, 384, 441syntax, 12, 14, 15, 23, 24, 26, 30,32, 35, 37, 42, 47, 65, 149, 150, 156, 159, 187, 192, 205, 206syntax highlighting example, 238– 240syntax tree, 206, 207, 209, 210, 230, 231SyntaxError type, 208tab character, 15, 34tab key, 345tabbed interface (exercise), 271,438tabindex attribute, 258, 345table, 70–72, 115, 249, 282table (HTML tag), 249, 273, 281,
443table example, 115–119, 122, 250,436tableFor function, 72tag, 223, 224, 229, 244 tagName property, 250 tainting, 368talk, 399, 400, 407–409, 416 talksAbout function, 233 tampering, 338tangent, 81target property, 255, 261, 349,443task management example, 77 taste, 188, 204TCP, 221, 324, 402td (HTML tag), 250template, 415, 417, 422, 448, 449 template-repeat attribute, 423, 448 tentacle (analogy), 25, 66, 69 ternary operator, 19, 22test method, 165test suite, 151, 152testing framework, 152text, 15, 188, 223, 229, 231, 239,textBaseline property, 308, 440 TextCell type, 119, 122 textContent property, 239, 442,443th (HTML tag), 250then method, 336, 337, 442 theory, 153this, 64, 107, 109, 134, 135, 137,142, 150, 193 thread, 266, 377, 378throw keyword, 156, 157, 160, 163, 393, 432Tiger type, 148tile, 317time, 166, 168, 170, 248, 269, 286,288, 289, 293, 295, 315,318, 416 time field, 365timeline, 225, 247, 252, 266, 377 timeout, 267, 401, 403, 411 times method, 277title, 413title (HTML tag), 223, 225 toDataURL method, 367, 368, 373 toLowerCase method, 64, 250 tool, 164, 186, 360, 362, 370, 372 tools object, 362top (CSS), 246–248, 251, 372 top-level scope, see global scope toString method, 108, 111–113,115, 129, 133, 387 toUpperCase method, 64, 250, 387 tr (HTML tag), 250trackDrag function, 363, 371, 444 trackKeys function, 292, 296 transform (CSS), 297 transformation, 310–313, 323, 439258, 307, 320, 321, 323,347, 350, 370, 383, 442 text field, 264, 270, 342–344, 347,348, 357, 369 text input, 29text node, 231, 233, 236, 361, 438 text wrapping, 320text-align (CSS), 250 TEXT_NODE code, 231, 438 textAlign property, 308, 440 textarea (HTML tag), 268, 343,347, 354, 357, 447475
translate method, 311, 312 Transmission Control Protocol, seeunicycling, 399uniformity, 206, 372uniqueness, 244unit (CSS), 249, 263Universal Resource Locator, seeURL Unix, 390, 392Unix time, 170, 403unlink function, 383unshift method, 76 UnterlinedCell type, 120 unwinding the stack, 156 upcasing server example, 387 upgrading, 190upload, 351URL, 222, 298, 326, 329, 339, 360,367, 369, 385, 389, 402,419URL encoding, 327, 449url module, 389, 410urlToPath function, 389, 396use strict, see strict modeuser experience, 252, 333, 345,372, 400, 416 user interface, 159users’ group, 399 UTF-8, 383validation, 137, 143, 154, 155, 162, 205, 276, 284, 347, 408,409, 411 value, 12value attribute, 342, 347, 350 var keyword, 24, 26, 44, 150 variable, 5, 28, 33, 35, 41, 42, 46,66, 70, 97, 159, 182, 213, 216, 219, 353TCPtransparent, 298, 309, 373, 374 transpilation, 216trapezoid, 322, 439traversal, 173tree, 99, 108, 206, 231trial and error, 153, 290, 304 triangle (exercise), 40, 424 trigonometry, 81, 248trim method, 79true, 17trust, 226try keyword, 157, 158, 333, 334,368, 393, 432, 442 Turkish, 270turn, 128, 129Twitter, 325type, 12, 16, 124, 149type attribute, 342, 346 type coercion, 19–21, 30 type property, 206, 254 typeof operator, 16, 85, 428 typing, 258, 268, 270typo, 149unary operator, 16uncaught exception, 159, 334, 335,393undefined, 19, 20, 26, 43, 49, 63,66, 150, 155 underline, 242underscore character, 25, 38, 117, 138, 179Unicode, 17, 166, 184, 185, 257, 258, 381476
assignment, 25, 44, 46 definition, 24, 219, 436from parameter, 43, 51 global, 44, 150, 193, 296, 379 model of, 25, 69naming, 25, 26, 38, 44, 55, 80, 151variadic function, 80vector (exercise), 126, 429 vector graphics, 308Vector type, 126, 129, 131, 151,276, 289, 440 verbosity, 360, 378, 393version, 194, 223, 325version control, 189View type, 131, 137, 138, 140 viewport, 260, 283, 285, 315, 316,319 virus, 226vocabulary, 42, 86, 87, 97, 101 void operator, 26volatile data storage, 11walk, 375walking, 318wall, 129, 134, 274wall following, 140, 431Wall type, 134WallFollower type, 140wave, 278, 289Web, see World Wide Webweb application, 7, 353, 359, 423 web browser, see browserweb programming, 228web sockets, 401web worker, 266WebDAV, 397477webgl (canvas context), 298 website, 226, 227, 326, 332, 397,399weekday example, 191, 195, 197,198, 203 weekend project, 397Weizenbaum, Joseph, 2 weresquirrel example, 61, 65, 68,69, 73, 74, 76 which property, 254while loop, 6, 33, 35, 56, 182, 288 whitespace, 34, 38, 79, 165, 166, 179, 184, 205, 208, 218,234, 402, 435, 438 why, 23width (CSS), 372window, 253, 255, 261, 265, 379 window variable, 82Windows, 396with statement, 151 withContext function, 157, 158 wizard (mighty), 4word boundary, 171word character, 166, 171, 184 work list, 445workbench (exercise), 357, 442 world, 128, 129, 272World type, 132, 134, 136, 138,141World Wide Web, 7, 93, 197, 220,222, 226, 227, 324 writable stream, 385, 386, 388,389write method, 385, 386writeFile function, 383, 386, 448 writeHead method, 385writing code, 8, 128
WWW, see World Wide WebXML, 232, 298, 328, 330, 331 XML namespace, 298 XMLHttpRequest, 328, 330, 332,340, 347, 397, 415, 447 xmlns attribute, 298yield (reserved word), 26 Yuan-Ma, 11, 376Zawinski, Jamie, 164zero-based counting, 60, 63, 170 zeroPad function, 57zigzag, 439zooming, 320478